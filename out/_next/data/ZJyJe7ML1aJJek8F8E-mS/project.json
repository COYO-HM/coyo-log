{"pageProps":{"posts":[{"frontMatter":{"date":"2023-02-23T00:00:00","title":"React Hook","tags":["React"],"description":"","published":false},"body":"# Hook\r\n\r\n> “Hook은 함수 컴포넌트에서 React state와 생명주기 기능을 연동할 수 있게 해주는 함수”\r\n>\r\n> - React Docs Hook\r\n\r\n- Hook은 class 안에서 동작하지 않는다.\r\n- Hook은 컴포넌트 혹은 커스텀 훅의 최상위 상단에만 호출할 수 있으며, 반복문(loops)이나 조건문(conditions) 안에서 호출할 수 없다.\r\n  만일 반복문이나 조건문 안에서 호출하고 싶다면, 새 컴포넌트를 생성하고 state를 해당 컴포넌트로 옮긴다.\r\n\r\n## Hook을 사용하는 이유\r\n\r\n- 상태 관련 로직을 추상화하여 컴포넌트 사이의 상태 로직의 재사용성을 높일 수 있다.\r\n- 생명 주기 메서드 기반이 아닌 유사 동작을 기반으로 컴포넌트를 작은 함수로 쪼개어 로직 추적 및 테스트 등을 보다 더 용이하게 할 수 있다.\r\n\r\n# State Hooks\r\n\r\n> `state`를 선언하고 업데이트 하는 Hook\r\n\r\n<aside>\r\n💡 `state`\r\n\r\n컴포넌트가 기억하고 있는 정보\r\n\r\n</aside>\r\n\r\n## `useState`\r\n\r\n```jsx\r\nconst [state, setState] = useState(initialState);\r\n```\r\n\r\n> 변수 선언을 위한 Hook으로 바로바로 업데이트 할 수 있다.\r\n>\r\n> ```jsx\r\n> function useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];\r\n> ```\r\n>\r\n> 함수 컴포넌트가 다시 렌더링 되어도 그대로 유지되는 `state`와 `state` 값을 업데이트할 수 있는 함수를 반환한다.\r\n>\r\n> 인자로 첫 번째 렌더링에서 사용되는 초기 `state` (어떤 타입이든 가능)를 받는다.\r\n>\r\n> class의 `this.setState`와 거의 유사하지만 이전 `state`와 새로운 `state`를 합치지 않는다.\r\n\r\n```jsx\r\nimport React, { useState } from \"react\";\r\n\r\nfunction Example() {\r\n  // \"count\"라는 새 상태 변수를 선언합니다\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>You clicked {count} times</p>\r\n      <button onClick={() => setCount(count + 1)}>Click me</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n### `setState`\r\n\r\n> `Dispatch<SetStateAction<state의 type>>`\r\n> state를 다른 값으로 업데이트 되는데 사용되며 리렌더링을 유발한다.\r\n\r\n<aside>\r\n💡 리렌더링을 유발하는 함수는 updater function\r\n\r\nReact는 updater function들을 queue에 넣고 컴포넌트를 리렌더한다.\r\n\r\n리렌더링이 발생하는 동안, React는 prev state 들을 queue에 있는 updater function을 적용하여 next state를 계산한다.\r\n\r\n</aside>\r\n\r\n- nextState를 그냥 넣을 수도 있지만 prevState를 함수 형태로 넣어서 상태를 변경시킬 수도 있다.\r\n  만일 함수 형태로 nextState를 넘겨주는 경우, prevState만을 유일한 argument로 사용하며 nextState를 반환하는 함수여야한다.\r\n\r\n  ```jsx\r\n  const [name, setName] = useState(\"Prev Name\");\r\n\r\n  useEffect(\r\n    () =>\r\n      setName((prevState) =>\r\n        prevState === \"Prev Name\" ? \"Next Name\" : \"Different Name\"\r\n      ),\r\n    [setName]\r\n  );\r\n  ```\r\n\r\n- 리렌더링 이후에 state의 값이 업데이트 되는 것이기에 만일 setState 함수를 호출한 후 바로 state를 읽어보면 아직 값이 업데이트 되지 않은 것을 알 수 있다.\r\n\r\n## `useReducer`\r\n\r\n> reducer 함수의 로직으로 state를 선언하고 업데이트 하는 Hook\r\n\r\n# Context Hooks\r\n\r\n<aside>\r\n💡 context\r\n\r\nprops를 넘겨받지 않고 정보(변수 등등)들을 먼 부모 컴포넌트로 부터 받는 것\r\n\r\n얼마나 깊이 자식 컴포넌트가 있는지 관계 없다.\r\n\r\n</aside>\r\n\r\n## `useContext`\r\n\r\n> context를 읽고 구독하는 Hook\r\n\r\n# Ref Hooks\r\n\r\n<aside>\r\n💡 Refs\r\n\r\nRefs는 DOM node 나 timeout ID와 같은 렌더링에 사용되지 않는 `state`와는 다른 정보들을 컴포넌트가 보유할 수 있도록 한다.\r\n\r\n</aside>\r\n\r\n- refs가 제공하는 정보는 state와는 다른 정보이기에 refs의 변화를 react가 알지못하고 컴포넌트 리렌더링이 발생하지 않는다.\r\n- Refs는 Browser APIs와 같은 non-React system 등과 일해야할 때 매우 유용하다.\r\n\r\n## `useRef`\r\n\r\n> ref를 정의하고 어떤 value 등 가능하다. 다만 주로 DOM node 로 자주 쓰인다.\r\n\r\n## `useImperativeHandle`\r\n\r\n> ref를 컴포넌트에 노출시킬 때 사용된다. 아주 드물게 사용된다.\r\n\r\n# Effect Hooks\r\n\r\n<aside>\r\n💡 Effects는 컴포넌트를 외부의 시스템(네트워크, 브라우저 DOM, 애니메이션, 다른 UI 라이브러리로 만들어진 위젯과 리액트 코드로 작성되지 않은 것)들과 연결하고 동기화하도록 한다.\r\n\r\n</aside>\r\n\r\n## `useEffect`\r\n\r\n> 함수 컴포넌트 내에서 Side Effects를 수행할 수 있게 해주는 Hook\r\n>\r\n> <aside>\r\n> 💡 Side Effects\r\n> React 컴포넌트 안에서 데이터를 가져오거나 구독하고, DOM을 직접 조작하는 작업으로 다른 컴포넌트에 영향을 주거나 렌더링 과정에서는 구현할 수 없는 작업\r\n>\r\n> </aside>\r\n>\r\n> class의 `componentDidMount`나 `componentDidUpdate`, `componentWillUnmount`와 같은 목적으로 하나의 API로 통합된 것이다.\r\n>\r\n> - 기본적으로 React는 첫번째 렌더링을 포함하여 매 렌더링 이후에 effects를 실행한다.\r\n\r\n```jsx\r\n// React가 DOM으로 업데이트한 뒤에 문서의 타이틀을 바꾸는 컴포넌트\r\nimport React, { useState, useEffect } from \"react\";\r\n\r\nfunction Example() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // componentDidMount, componentDidUpdate와 비슷합니다\r\n  useEffect(() => {\r\n    // 브라우저 API를 이용해 문서의 타이틀을 업데이트합니다\r\n    document.title = `You clicked ${count} times`;\r\n  });\r\n\r\n  return (\r\n    <div>\r\n      <p>You clicked {count} times</p>\r\n      <button onClick={() => setCount(count + 1)}>Click me</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n## `useLayoutEffect`\r\n\r\n## `useInsertionEffect`\r\n\r\n# Performance Hooks\r\n\r\n## `useMemo`\r\n\r\n## `useCallback`\r\n\r\n# Other Hooks\r\n\r\n## `useDebugValue`\r\n\r\n> React DevTools가 표시하는 label을 커스텀 하는 Hook\r\n\r\n## `useId`\r\n\r\n> 컴포넌트와 고유한 ID를 연결할 때 사용하는 Hook으로 주로 API와 연결할 때 사용\r\n\r\n## `useSyncExternalStore`\r\n\r\n> 컴포넌트가 외부 저장소를 구독하게 하는 Hook\r\n\r\n# 참조\r\n\r\n- [리액트 공식 문서 Hook](https://ko.reactjs.org/docs/hooks-intro.html)\r\n- [리액트 공식 문서 Beta Hook](https://beta.reactjs.org/reference/react)\r\n","fields":{"slug":"blog/react/hook"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/react/hook.md"},{"frontMatter":{"date":"2023-02-21T00:00:00","title":"Greedy 알고리즘","tags":["Algorithm"],"description":"","published":false},"body":"# Greedy Algorithm\r\n\r\n> 현재 상황에서 지금 당장 좋은 것만 고르는 방법\r\n","fields":{"slug":"blog/algorithm/greedy"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/algorithm/greedy.md"},{"frontMatter":{"date":"2023-02-11T00:00:00","title":"NextJS Image 정리","tags":["NextJS","TypeScript"],"description":"NextJS 공식 Docs 정리 해보기","published":false},"body":"[NextJS/Image Docs](https://nextjs.org/docs/api-reference/next/image#loader-configuration)\r\n\r\n# Configuration Options\r\n","fields":{"slug":"blog/nextJS/next-image"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/nextJS/next-image.md"},{"frontMatter":{"date":"2023-02-10T00:00:00","title":"NextJS 블로그 배포 시 이미지 경로 설정","tags":["NextJS","TypeScript"],"description":"NextJS 블로그 배포 시에 이미지 경로 설정하기","published":false},"body":"NextJS 블로그 생성 시에 NextJS `<Image/>` tag 사용 시에 경로를 반드시 설정 해주어야 배포할 수 있다.\r\n\r\n`next.config.js`\r\n\r\n```javascript\r\n/** @type {import('next').NextConfig} */\r\n\r\nmodule.exports = {\r\n  reactStrictMode: true,\r\n  images: {\r\n    domains: [\"블로그 주소\"],\r\n    loader: \"imgix\",\r\n    path: \"블로그 주소\",\r\n  },\r\n};\r\n```\r\n\r\n# 참조\r\n\r\n- [NextJS/Image Docs](https://nextjs.org/docs/api-reference/next/image#loader-configuration)\r\n","fields":{"slug":"blog/nextJS/next-image-upload"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/nextJS/next-image-upload.md"},{"frontMatter":{"date":"2023-02-06T00:00:00","title":"npm 정리","tags":["npm"],"description":"","published":false},"body":"# NPM\r\n\r\n<aside>\r\n    <code>npx</code>\r\n    \r\n    npm 5.2+ 버전의 패키지 실행 도구\r\n</aside>\r\n\r\n## package 삭제하기\r\n\r\n```bash\r\nnpm uninstall package-name\r\n```\r\n\r\n### Dev Dependency Package 삭제하기\r\n\r\n```bash\r\nnpm uninstall -D package-name\r\n#또는\r\nnpm uninstall --save-dev package-name\r\n```\r\n\r\n### Global Package 삭제하기\r\n\r\n```bash\r\nnpm uninstall -g package-name\r\n```\r\n\r\n## `package.json`에 있는 항목 모두 업데이트 하기\r\n\r\n```bash\r\nnpx npm-check-updates -u\r\nnpm install\r\n```\r\n","fields":{"slug":"blog/npm/npm"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/npm/npm.md"},{"frontMatter":{"date":"2023-02-02T00:00:00","title":"TEST","tags":["React","TypeScript","Redux","SCSS","CSS","Network"],"description":"개발용 테스트 문서입니다. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","published":false},"body":"# 설치\r\n\r\n```bash\r\nnpm install @reduxjs/toolkit\r\n\r\nyarn add @reduxjs/toolkit\r\n\r\n```\r\n\r\n## HEADER 2\r\n\r\n### HEADER 3\r\n\r\n#### HEADER 4\r\n\r\n##### HEADER 5\r\n\r\n###### HEADER 6\r\n\r\n# Store\r\n\r\n```TypeScript\r\nimport { configureStore } from '@reduxjs/toolkit'\r\n\r\nexport const store = configureStore({\r\n  reducer: {},\r\n})\r\n\r\nexport type RootState = ReturnType<typeof store.getState>\r\nexport type AppDispatch = typeof store.dispatch\r\n```\r\n\r\n`index.tsx`\r\n\r\n```TypeScript\r\nimport React from 'react'\r\nimport ReactDOM from 'react-dom'\r\nimport './index.css'\r\nimport App from './App'\r\nimport { store } from './app/store'\r\nimport { Provider } from 'react-redux'\r\n\r\nReactDOM.render(\r\n  <Provider store={store}>\r\n    <App />\r\n  </Provider>,\r\n  document.getElementById('root')\r\n)\r\n```\r\n\r\n# `UseDispatch`, `UseSelector`\r\n\r\n```TypeScript\r\nimport { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\r\nimport type { AppDispatch, RootState } from '../Store';\r\n\r\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\r\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\r\n```\r\n\r\n# CreateSlice\r\n\r\n`ExampleReducer.ts`\r\n\r\n```TypeScript\r\ninterface IExampleState {\r\n\t// reducer type들 표시\r\n\tuserInfo: {name: string, id: string} | null\r\n}\r\n\r\nconst initialState: IExampleState = {\r\n\t// 초기 상태 설정\r\n\tuserInfo: null\r\n}\r\n\r\nexport const ExampleSlice = createSlice({\r\n\tname: 'EXAMPLE',\r\n\tinitialState,\r\n\treducers: {\r\n\t\tupdateName: (state, action) => {\r\n\t\t\tstate.userInfo: {\r\n\t\t\t\t...state.userInfo,\r\n\t\t\t\taction.payload\r\n\t\t\t}\r\n\t\t},\r\n\t},\r\n\textraReducers: (builder) => {\r\n\t\tbuilder.addcase(getUserInfoAsync.fullfilled, (state, {payload}) => {\r\n\t\t\tstate.userInfo = payload\r\n\t\t})\r\n\t}\r\n})\r\n\r\nexport const { updateName } = ExampleSlice.actions\r\nexport const ExampleReducer = {\r\n\texample: ExampleSlice.reducer\r\n}\r\n```\r\n\r\n# CreateAsyncThunk\r\n\r\n```TypeScript\r\nexport const getUserInfoAsync = createAsyncThunk<\r\n  {\r\n    /*성공시에 출력될 data의 type*/\r\n  },\r\n  {\r\n    /*param의 type*/\r\n  }\r\n>('EXAMPLE/getUserInfoAsync', async (param) => await axios.method('url', param));\r\n```\r\n\r\n# 참조\r\n\r\n- [Redux-ToolKit Docs](https://redux-toolkit.js.org/tutorials/quick-start)\r\n\r\n# 12321$-+\\_\r\n","fields":{"slug":"blog/test/test"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/test/test.mdx"},{"frontMatter":{"date":"2022-10-03T00:00:00","title":"Simple Kanban Board","tags":["React","TypeScript","react-beautiful-dnd","react-hook-form","recoil","styled-components"],"description":"react-beautiful-dnd를 이용한 간단한 칸반 보드","published":false,"thumbnail":"/static/images/project/simple_kanban_board.jpg"},"body":"> 해당 프로젝트는 다음 링크를 통해 볼 수 있습니다.\r\n>\r\n> [https://coyo-hm.github.io/Simple-Kanban-Board/](https://coyo-hm.github.io/Simple-Kanban-Board/)\r\n\r\n# Introduction\r\n\r\n![ezgif com-gif-maker](https://user-images.githubusercontent.com/56423604/190454639-62c2abb5-359b-4e33-bc6a-fe45c2fcf3c1.gif)\r\n![ezgif com-gif-maker (1)](https://user-images.githubusercontent.com/56423604/190454736-c55b9ec0-4d28-436e-bb20-7955f2828167.gif)\r\n\r\n> react-beautiful-dnd를 이용한 간단한 칸반 보드입니다.\r\n>\r\n> - react-beautiful-dnd를 이용하여 Drag&Drop이 가능한 Kanban Board를 구현하였습니다.\r\n> - 카드끼리의 위치 이동은 물론 보드끼리의 위치 이동과 보드에서 다른 보드로 카드를 이동시킬 수도 있습니다.\r\n> - 사용자는 + 버튼을 눌러 보드를 추가할 수도 있으며 아래의 휴지통으로 카드나 보드를 Drag&Drop하여 삭제할 수 있습니다.\r\n> - Context API를 사용하여 테마 토글을 추가하였습니다. 테마 토글을 사용하여 다크 테마와 기본 테마를 설정할 수 있습니다.\r\n> - 사용자의 화면에 따라 CSS가 달라지도록 반응형으로 구현하였습니다.\r\n> - 보드 정보는 Local Storage에 저장하여 브라우저를 종료하더라도 해당 내용이 유지됩니다.\r\n\r\n# Quick Start\r\n\r\n```shell\r\nnpm install\r\nnpm start\r\n```\r\n\r\n# Project Structure\r\n\r\n```Plain text\r\nsrc\r\n│\r\n├── atoms ────────────────  Global State\r\n│\r\n├── components ───────────  view 컴포넌트\r\n│   ├── DraggableBoard\r\n│   ├── DraggableCard\r\n│   ├── DroppableArea\r\n│   └── Home\r\n│\r\n├── helpers ──────────────  공통 상수\r\n│   └── constant\r\n│\r\n├── hooks ────────────────  hook\r\n│   └── useTheme\r\n│\r\n├── images ───────────────  이미지 파일\r\n│\r\n│\r\n├── style ────────────────  styled-components' custom style & GlobalStyle\r\n│   ├── globalStyle\r\n│   └── index\r\n│\r\n├── theme ────────────────  theme 관련\r\n│   ├── ToggleTheme\r\n│   ├── styled.d.ts\r\n│   └── theme\r\n│\r\n├── App.js ───────────────  Theme Context 적용 & GlobalStyle 적용\r\n│\r\n└── index.js ─────────────  애플리케이션 엔트리 포인트\r\n```\r\n\r\n# Tech Stack\r\n\r\n- react v_18.2.0\r\n- react-beautiful-dnd v_13.1.0\r\n- react-dom v_18.2.0\r\n- react-helmet v_6.1.0\r\n- react-hook-form v_7.34.0\r\n- recoil v_0.7.4\r\n- styled-components v_5.3.5\r\n- typescript v_4.8.3\r\n","fields":{"slug":"project/simple-kanban-board"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/project/simple-kanban-board.mdx"},{"frontMatter":{"date":"2022-09-15T00:00:00","title":"REAL TIME COIN INFO","tags":["React","TypeScript","react-helmet","react-query","react-apexcharts","recoil","styled-components"],"description":"코인 정보와 실시간 가격을 CANDLE STICK CHART로 볼 수 있는 서비스","published":false,"thumbnail":"/static/images/project/real-time-coin-info.gif"},"body":"# Introduction\r\n\r\n![ezgif com-gif-maker](https://user-images.githubusercontent.com/56423604/190454639-62c2abb5-359b-4e33-bc6a-fe45c2fcf3c1.gif)\r\n![ezgif com-gif-maker (1)](https://user-images.githubusercontent.com/56423604/190454736-c55b9ec0-4d28-436e-bb20-7955f2828167.gif)\r\n\r\n> 무료 api를 사용하여 coin들의 정보를 보여주는 서비스입니다.\r\n>\r\n> - `apexchart`를 사용하여 코인의 가격을 CandleStick Chart의 형태로 시각화하였습니다.\r\n>\r\n> - `recoil`을 사용하여 전역변수 관리를 해주었습니다.\r\n>\r\n> - `styled component`의 ThemeProvider를 사용하여 themeToggle를 구현하였습니다.\r\n\r\n# Quick Start\r\n\r\n```shell\r\nnpm install\r\nnpm start\r\n```\r\n\r\n# Project Structure\r\n\r\n```Plain Text\r\nsrc\r\n├── api ──────────────────  Fetching Data\r\n│\r\n├── atoms ────────────────  Global State\r\n│\r\n├── components ───────────  view 컴포넌트\r\n│   ├── Charts\r\n│   └── ToggleSwitch\r\n│\r\n├── images ───────────────  이미지 파일\r\n│\r\n├── pages ────────────────  페이지\r\n│   ├── Coin\r\n│   └── Home\r\n│\r\n├── style ────────────────  styled-components' custom style & theme & GlobalStyle\r\n│   ├── globalStyle\r\n│   ├── index\r\n│   ├── styled.d.ts\r\n│   └── theme\r\n│\r\n├── App.js ───────────────  Route 처리 & Theme Context 적용 & GlobalStyle 적용\r\n│\r\n└── index.js ─────────────  애플리케이션 엔트리 포인트\r\n```\r\n\r\n# Tech Stack\r\n\r\n- react v_18.2.0\r\n- react-router-dom v_6.3.0\r\n- typescript v_4.7.4\r\n- styled-components v_5.3.5\r\n- recoil v_0.7.4\r\n- react-helmet v_6.1.0\r\n- react-query v_4.0.0\r\n- react-apexcharts v_1.4.0\r\n","fields":{"slug":"project/real-time-coin-info"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/project/real-time-coin-info.mdx"},{"frontMatter":{"date":"2022-09-15T00:00:00","title":"URI와 URL","tags":["Network"],"description":"","published":false},"body":"# URI\r\n\r\n> URI(Uniform Resource Identifier)\r\n>\r\n> 특정 리소스를 식별하는 <span className=\"yellow\">통합 자원 식별자</span>를 의미한다.<br/>\r\n> 웹 기술에서 사용하는 모든 리소스(논리적 또는 물리적 리소스)를 식별하는 고유한 문자열 시퀀스이다.\r\n\r\n- Uniform : 리소스를 식별하는 통일된 방식\r\n- Resource : URI로 식별 가능한 모든 자원\r\n- Identifier : 다른 항목과 구분하기 위해 필요한 고유한 정보\r\n\r\n## URI의 구조\r\n\r\n```\r\nscheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]\r\n```\r\n\r\n1. `scheme`: 사용할 프로토콜을 뜻하며 웹에서는 http 또는 https를 사용\r\n2. `user`, `password`: (서버에 있는) 데이터에 접근하기 위한 사용자의 이름과 비밀번호\r\n3. `host`와 `port`: 접근할 대상(서버)의 호스트명과 포트번호\r\n4. `path`: 접근할 대상(서버)의 경로에 대한 상세 정보\r\n5. `query`: 접근할 대상에 전달하는 추가적인 정보(parameter)\r\n6. `fragment`: 메인 리소스 내에 존재하는 서브 리소스에 접근할 때 이를 식별하기 위한 정보\r\n\r\n# URL\r\n\r\n> URL(Uniform Resource Locator)\r\n>\r\n> 흔히 웹 주소라고 말하는 것이며, 컴퓨터 네트워크 상에서 리소스의 위치를 알려주기 위한 규약이다.<br/>\r\n> URI의 속하는 부분 집합이다.\r\n\r\n# URI VS. URL\r\n\r\n<aside>\r\n\r\n- URI는 식별하고, URL은 위치를 가르킨다.\r\n- URI의 속하는 부분 집합이다.\r\n\r\n</aside>\r\n","fields":{"slug":"blog/network/url-uri"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/network/url-uri.md"},{"frontMatter":{"date":"2022-09-05T00:00:00","title":"Immutability","tags":["JavaScript"],"description":"Immutability","published":false},"body":"### Immutability\r\n\r\n> Immutability(변경불가성)는 객체가 생성된 이후 그 상태를 변경할 수 없는 디자인 패턴\r\n\r\n- JavaScript의 모든 `obejcts`와 `arrays`는 모두 기본적으로 변경 가능(mutable) 하다.\r\n  ```jsx\r\n  const obj = { a: 1, b: 2 };\r\n  // still the same object outside, but the contents have changed\r\n  obj.b = 3;\r\n\r\n  const arr = [\"a\", \"b\"];\r\n  // In the same way, we can change the contents of this array\r\n  arr.push(\"c\");\r\n  arr[1] = \"d\";\r\n  ```\r\n  이를 mutating the object or array(object나 array를 변환)라고 부른다. 메모리에서 똑같은 object나 array를 참조하기에 같은 값을 참조하는 다른 object나 array를 변화하면 기존의 object나 array에서도 새로운 값이 호출된다.\r\n  ⇒ 값을 변경하지 않고(Immutably) 업데이트하려면 코드가 기존 object/array의 복사본을 만든다음 복사본을 수정해야 한다.\r\n  ```jsx\r\n  const obj = {\r\n    a: {\r\n      // To safely update obj.a.c, we have to copy each piece\r\n      c: 3,\r\n    },\r\n    b: 2,\r\n  };\r\n\r\n  const obj2 = {\r\n    // copy obj\r\n    ...obj,\r\n    // overwrite a\r\n    a: {\r\n      // copy obj.a\r\n      ...obj.a,\r\n      // overwrite c\r\n      c: 42,\r\n    },\r\n  };\r\n\r\n  const arr = [\"a\", \"b\"];\r\n  // Create a new copy of arr, with \"c\" appended to the end\r\n  const arr2 = arr.concat(\"c\");\r\n\r\n  // or, we can make a copy of the original array:\r\n  const arr3 = arr.slice();\r\n  // and mutate the copy:\r\n  arr3.push(\"c\");\r\n  ```\r\n\r\n## Map\r\n\r\n---\r\n\r\n## List\r\n\r\n---\r\n","fields":{"slug":"blog/javascript/Immutable"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/javascript/Immutable.md"},{"frontMatter":{"date":"2022-03-22T00:00:00","title":"React useMemo와 useCallback","tags":["React","JavaScript"],"description":"React useMemo와 useCallback","published":false},"body":"# `useMemo`\r\n\r\n```javascript\r\nuseMemo(() => fn, [deps]);\r\n```\r\n\r\n> deps가 변한다면, fn 함수 실행 후 값을 반환한다.\r\n\r\n- 동일한 입력이 들어온다면 재활용하여 중복 연산을 피할 수 있다.\r\n\r\n# `useCallback`\r\n\r\n```javascript\r\nuseCallback(fn, [deps]);\r\n```\r\n\r\n> deps가 변한다면, fn 이라는 새로운 함수를 반환한다.\r\n","fields":{"slug":"blog/react/useMemo-useCallback"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/react/useMemo-useCallback.md"},{"frontMatter":{"date":"2022-03-17T00:00:00","title":"REST API","tags":["Network"],"description":"REST 아키텍쳐의 제약조건을 준수하는 어플리케이션 프로그래밍 인터페이스","published":false},"body":"# REST API (Restful API)\r\n\r\n> REST(Representational State Transfer) 아키텍쳐의 제약조건을 준수하는 어플리케이션 프로그래밍 인터페이스\r\n\r\n# REST (Representational State Transfer)\r\n\r\n## REST의 구성\r\n\r\n- 정보의 자원(Resource)\r\n\r\n# API (Application Programming Interface)\r\n\r\n> 어플리케이션 소프트웨어를 구축하고 통합하는 정의 및 프로토콜 세트로 때때로 API는 정보 제공자와 정보 사용자 간의 계약으로 지칭되며 소비자에게 필요한 콘텐츠(호출)과 생상자에게 필요한 콘텐츠(응답)를 구성한다.\r\n","fields":{"slug":"blog/network/rest-api"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/network/rest-api.md"},{"frontMatter":{"date":"2022-01-16T00:00:00","title":"JavaScript","tags":["JavaScript"],"description":"undefined와 null 비교","published":false},"body":"# `undefined`\r\n\r\n> 변수를 선언하고 값을 할당하지 않는다.\r\n\r\n# `null`\r\n\r\n> 변수 선언 후 빈 값을 할당한다.\r\n","fields":{"slug":"blog/javascript/undefined-null"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/javascript/undefined-null.md"},{"frontMatter":{"date":"2022-01-13T00:00:00","title":"Git 내용정리","tags":["Git"],"description":"git 초기 설정, git 커밋 메세지 수정","published":false},"body":"# Git 초기 설정\r\n\r\n## 초기 사용자 설정\r\n\r\n```bash\r\ngit config --global user.name \"사용자 이름\"\r\ngit config --global user.email 사용자 이메일\r\n```\r\n\r\n> `git config --list`\r\n\r\n# Git commit\r\n\r\n## Git commit 메세지 수정\r\n\r\n```bash\r\ngit commit --amend -m \"메세지 내용\"\r\n```\r\n","fields":{"slug":"blog/git/git"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/git/git.md"},{"frontMatter":{"date":"2022-01-12T00:00:00","title":"Jest","tags":["Jest","JavaScript"],"description":"","published":false},"body":"# Jest\r\n\r\n> TDD(Test-Driven Development) 단순성에 초점을 맞춘 자바스크립트 테스트 프레임 워크\r\n\r\n> TDD(Test-Driven Development)\r\n>\r\n> 소프트웨어 개발 방법론 중 하나로 테스트코드를 먼저 작성한 후에 구현 코드를 작성 단계와 리펙토링 단계를 짧은 주기로 반족하는 테스트 주도 개발 방법론\r\n\r\n- zero config\r\n\r\n  별도의 설정 없이 바로 작업하는 것을 목표로 한다.\r\n\r\n- snapshots\r\n\r\n  큰 객체로 테스트하는 것을 쉽게 만든다. 스냅샷 또는 인라인에 저장된 객체화 함께 테스트가 실행된다.\r\n\r\n- isolated\r\n\r\n  성능을 극대화하기 위해 테스트들은 각각의 프로세스에서 병렬 실행된다.\r\n\r\n- greatapi\r\n\r\n  `it`, `expect`와 같은 Framework, Assertion API를 모두 가지고 있다.\r\n\r\n# Jest api 정리\r\n\r\n## `toBe`\r\n\r\n> 정확한 값 일치 여부 확인\r\n\r\n```javascript\r\nexpect(2 + 2).toBe(4);\r\n```\r\n","fields":{"slug":"blog/jest/jest"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/jest/jest.md"},{"frontMatter":{"date":"2021-07-13T00:00:00","title":"Git branch 정리","tags":["Git"],"description":"Git branch 관련 정리","published":false},"body":"# 브랜치 생성\r\n\r\n# 브랜치 이름 변경\r\n\r\n```bash\r\ngit branch -m 이전이름 새로운 이름\r\n```\r\n\r\n# 브랜치 버전 확인\r\n\r\n```bash\r\ngit branch -v\r\n```\r\n\r\n# 특정 브랜지에서 `pull` 받기\r\n\r\n```bash\r\ngit pull origin 브랝치 이름\r\n```\r\n\r\n# 브랜치 삭제\r\n\r\n```bash\r\ngit branch -d 브랜치 이름\r\n```\r\n","fields":{"slug":"blog/git/git-branch"},"path":"C:/Users/dayeo/YODA/git/Personal Project/coyo-log/content/blog/git/git-branch.md"}],"tags":[{"tag":"React","count":10},{"tag":"JavaScript","count":9},{"tag":"TypeScript","count":8},{"tag":"Network","count":6},{"tag":"NextJS","count":2},{"tag":"Redux","count":2},{"tag":"recoil","count":2},{"tag":"styled-components","count":2},{"tag":"Git","count":2},{"tag":"GithubPage","count":1},{"tag":"Algorithm","count":1},{"tag":"npm","count":1},{"tag":"SCSS","count":1},{"tag":"CSS","count":1},{"tag":"Emotion","count":1},{"tag":"Gatsby","count":1},{"tag":"react-beautiful-dnd","count":1},{"tag":"react-hook-form","count":1},{"tag":"react-helmet","count":1},{"tag":"react-query","count":1},{"tag":"react-apexcharts","count":1},{"tag":"Jest","count":1},{"tag":"Lodash","count":1}]},"__N_SSG":true}