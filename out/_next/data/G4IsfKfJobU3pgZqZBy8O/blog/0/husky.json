{"pageProps":{"posts":[{"frontMatter":{"date":"2023-10-25T15:00:00","title":"commitlint로 commit-message 관리하기","tags":["husky","git","commitlint"],"description":"commitlint로 규칙 커스텀해서 커밋 메세지 관리해보자","published":true,"thumbnail":"https://user-images.githubusercontent.com/56423604/278075494-8932e44f-b2ea-49d8-8c5d-c1b2805fd0ab.png"},"body":"husky 설치 및 git hook에 관련한 내용은 [링크된 포스트](https://coyo-hm.github.io/blog/post/husky-git-hook)를 참고하자.\n\n이전 포스트에서 git template을 사용하여 git commit message를 작성할 때 가이드 라인을 생성해주었다. 그런데 이는 말그대로 가이드 라인이기에 규칙을 어기더라도 아무런 일이 일어나지 않는다. 규칙을 강제하지 않는다.\n\n그래서 오타가 나거나 규칙이 어긋나더라도 그대로 commit message가 올라간다. 이러한 불상사를 방지하기 위해서 git hook을 사용하여 만일 commit message가 설정한 규칙에 벗어나면 commit 되지 않도록 해주도록 해보자.\n\n# commitlint\n\n직접 스크립트를 작성하는 방법도 있지만 [`commitlint`](https://commitlint.js.org/#/) 를 사용해주었다. `commitlint` 는 `commitlint.config.js` 파일을 생성해서 적용해주면 규칙을 커스텀할 수 있다.\n\n## 설치\n\n```bash\n# npm을 사용하는 경우\nnpm install --dev @commitlint/config-conventional @commitlint/cli\n\n# yarn을 사용하는 경우\nyarn add --dev @commitlint/config-conventional @commitlint/cli\n```\n\n설치 후 프로젝트 루트 디렉토리에 `commitlint.config.js` 생성하고 `@commitlint/config-conventional`를 extends 추가해주어 [Conventional Commits Rule](https://www.conventionalcommits.org/en/v1.0.0/)을 따를 수 있도록 해준다.\n\n```json\n{\n  \"extends\": [\"@commitlint/config-conventional\"],\n}\n```\n\n## 적용\n\n`commlint`를 commit-msg hook 에 축가해준다.\n\n```bash\n# 스크립트 생성 없이 하는 방법\nnpx husky add .husky/commit-msg \"npx commitlint --edit \"$1\"\"\n\nor\n\n# 스크립트 생성하는 방법\nnpm pkg set scripts.commitlint=\"commitlint --edit\"\nnpx husky add .husky/commit-msg 'npm run commitlint ${1}'\n```\n\n<aside>\n  💡 다음과 같이 패키지 설치 없이 바로 적용할 수 있다.\n\n  ```bash\n  #!/bin/sh\n  . \"$(dirname \"$0\")/_/husky.sh\"\n\n  npx --no -- commitlint --edit ${1}\n  ```\n\n</aside>\n\n다음과 같이 commit-msg 에 commlint 스크립트가 생성된 것을 확인할 수 있다.\n\n![commit-msg-hook](https://user-images.githubusercontent.com/56423604/278076031-666343a5-4391-465c-a204-7508df2fe80a.png)\n\n## 규칙 커스텀하기\n\n[commlint docs](https://github.com/conventional-changelog/commitlint/blob/master/docs/reference-rules.md)에 보면 자세한 규칙 설정 방법과 지원하는 규칙을 확인할 수 있다. `rules`에 커스텀 규칙을 추가하면 된다.\n\n```json\n \"subject-case\": [\n      2,\n      \"always\",\n      [\"sentence-case\", \"start-case\", \"pascal-case\", \"upper-case\", \"lower-case\"]\n    ],\n```\n\n위의 규칙을 살펴보면 `subject-case` 라는 규칙에 적용 방식이 배열로 들어간다. 순서대로 level, applicable, value를 지정할 수 있다.\n\n- level (`0`, `1`, `2`): 규칙을 어떤식으로 처리할 지 지정한다. `0`은 비활성화, `1`은 경고, `2`는 오류로 처리한다.\n- applicable (`always`, `never`): `always`는 규칙 허용, `never`은 해당 규칙 비허용(규칙 반대 적용)이란 의미로\n\n만일, `subject-empty` 규칙이 비허용이란 말은 subject 부분이 비면 안된다는 규칙이다.\n\n- value는 각각 규칙에 적용되는 값으로, 대문자 허용 여부 등등의 각각의 규칙마다 다르지만 보통 아래의 규칙 등을 적용할 수 있고, 실제로 포함되어야 하는 값들을 설정할 수도 있다.\n\n  ```\n  [\n    'lower-case', // default\n    'upper-case', // UPPERCASE\n    'camel-case', // camelCase\n    'kebab-case', // kebab-case\n    'pascal-case', // PascalCase\n    'sentence-case', // Sentence case\n    'snake-case', // snake_case\n    'start-case', // Start Case\n  ];\n    ```\n\n\n```json\n{\n  \"extends\": [\"@commitlint/config-conventional\"],\n  \"rules\": {\n    \"subject-case\": [\n      2,\n      \"always\",\n      [\"sentence-case\", \"start-case\", \"pascal-case\", \"upper-case\", \"lower-case\"]\n    ],\n    \"type-enum\": [\n      2,\n      \"always\",\n      [\n        \"BUILD\",\n        \"CHORE\",\n        \"CONTENT\",\n        \"DOCS\",\n        \"FEAT\",\n        \"FIX\",\n        \"REFACTOR\",\n        \"STYLE\",\n        \"TEST\",\n        \"DEPLOY\"\n      ]\n    ],\n    \"type-case\": [2, \"always\",\"upper-case\"]\n  }\n}\n```\n\n[Conventional Commits Rule](https://www.conventionalcommits.org/en/v1.0.0/) 에 이전에 커스텀한 type-enum을 적용해주었다. 또한 type의 경우 개인의 취향이 대문자여서 모두 대문자로 처리하였고 만일 규칙에 어긋날 경우 모두 오류가 발생하도록 처리해주었다.\n\n## 테스트\n\n잘 적용되었는지 확인해보기 위해 고의적으로 규칙에 맞지 않게 ‘committest’라고 commit message를 적었다.\n\n![image](https://github.com/COYO-HM/COYO-HM.github.io/assets/56423604/059bcd54-0e45-46db-8da4-7a0c5f138c5c)\n\nerror가 발생하여 commit 에 실패한 것을 확인할 수 있었다. error message를 살펴보면 어떤 오류가 발생했는지 알 수 있다.\n\n![image](https://github.com/COYO-HM/COYO-HM.github.io/assets/56423604/983f5eb4-a355-4f50-9fa0-481f79c8e4fa)\n\ntype과 subject를 적지 않았음을 알 수 있다.\n\n이번엔 규칙에 맞게 commit message를 작성해보았다.\n\n![image](https://github.com/COYO-HM/COYO-HM.github.io/assets/56423604/15369756-b994-4e47-9e93-c132fc745d82)\n\n아무 문제 없이 커밋되는 것을 확인할 수 있었다.\n\n![image](https://github.com/COYO-HM/COYO-HM.github.io/assets/56423604/aabfb190-5ab3-4a26-b330-6af0002dbcd5)\n\n\n# 참조\n\n- [효율적인 커밋 메세지 관리를 위한 Conventional Commits 적용하기](https://blog.flynnpark.dev/13)\n- [Github: commitlint > docs > reference-rules](https://github.com/conventional-changelog/commitlint/blob/master/docs/reference-rules.md)\n- [Conventional Commits Rule](https://www.conventionalcommits.org/en/v1.0.0/)","fields":{"slug":"blog/post/husky-commlint"},"path":"blog/husky-commlint.mdx"},{"frontMatter":{"date":"2023-10-10T15:00:00","title":"husky로 git hook 편하게 관리하기","tags":["husky","git"],"description":"git hook은 무엇인지 살펴보고 husky로 git hook 쉽게 적용해보기","published":true,"thumbnail":"https://user-images.githubusercontent.com/56423604/276647708-f2c4971b-48db-40bc-8601-d1bd708d34c1.png"},"body":"# Git Hooks\n\ngit 에서 제공하는 특정 상황에서 특정 스크립트를 실행할 수 있는 기능으로 크게 클라이언트 훅과 서버 훅으로 나눌 수 있다.\n\n## 서버 훅\n\n- 서버 훅 은 Git repository 로 push 가 발생했을 때 서버에서 실행하는 훅\n\n<aside>\n  💡 저장소를 Clone 해도 클라이언트 훅은 복사되지 않는다. 만든 설정한 훅이 반드시 적용되도록 하려면 서버 훅을 이용해야만 한다.\n\n</aside>\n\n## 클라이언트 훅\n\n- 클라이언트 훅은 커밋, Merge 가 발생하거나 push 가 발생하기 전 클라이언트에서 실행하는 훅\n- 클라이언트 훅은 committing-workflow hooks, email-workflow hooks, 그리고 기타 hooks 으로 분류할 수 있다.\n\n### Committing-Workflow Hooks\n\n`git commit` 명령으로 커밋을 할 때 실행하는 Hook\n\n| hook | description |\n| --- | --- |\n| pre-commit | commit할 때 가장 먼저 호출되는 훅으로 commit message를 작성하기 전에 실행 |\n| prepare-commit-msg | Git이 commit message를 생성하고 나서 편집기를 실행하기 전에 실행 |\n| commit-msg | 최종적으로 commit이 완료되기 전에 프로젝트 상태나 commit message를 검증하기 위해 실행 |\n| post-commit | commit 을 완료한 후 실행 |\n\n### Email Workflow Hooks\n\n`git am` 명령으로 이메일을 통해 patch 파일을 적용할 때 실행하는 Hook\n\n| hook | description |\n| --- | --- |\n| applypatch-msg | `git am` 명령 실행 시 제일 먼저 실행 |\n| pre-applypatch | patch 적용 후 실행하며, `git am` 명령(patch)을 취소시킬 수 있음 |\n| post-applypatch | `git am` 명령에서 마지막으로 실행하며, patch 를 중단시킬 수 없음 |\n\n### Etc Hooks\n\nrebase, merge, push 와 같은 이벤트를 실행할 때 실행하는 Hook\n\n| hook | description |\n| --- | --- |\n| pre-rebase | rebase 하기 전에 실행, 이미 Push 한 커밋을 rebase 하지 못하게 할 수 있다.  |\n| post-rewrite | `git commit –amend`, `git rebase` 와 같이 commit을 변경하는 명령을 실행한 후 실행 |\n| post-merge | merge 가 끝나고 나서 실행 |\n| pre-push | `git push` 명령 실행 시 동작하며 리모트 정보를 업데이트 하고 난 후 리모트로 데이터를 전송하기 전에 실행, push 를 중단시킬 수 있음 |\n\n## Git Hooks 적용 방법\n\ngit을 설정한 파일 디렉토리 안에 .git 디렉토리가 만일 생성되지 않았다면 숨김 파일도 보기를 켜놓았는지 확인해봐야 한다.\n\nhook을 달리 설정한 것이 없다면 .git/hooks 폴더 안에 다음과 같이 위에서 보았던 Hook과 이름이 동일하지만 뒤에 `.sample` 이라는 확장자가 붙은 파일을 확인할 수 있다.\n\nhook은 실행 가능한 스크립트이며, 설정하고자 하는 훅 이름을 확장자 없이 파일명으로 지정하면 되기에 원하는 hook 의 `.sample` 이라는 확장자를 지우면 각 상황에 샘플이 바로 적용된다.\n\n<img alt={\"git-hook-dir\"} style={{margin:\"20px auto 10px\"}} src={\"https://user-images.githubusercontent.com/56423604/276653286-714e61cf-ebc9-4724-b804-4891aeb90351.png\"}/>\n\ngit hook을 직접 작성하여 사용하거나 다른 디렉토리에 백업하여 공유하는 방법들이 있으나 [🐶 husky](https://typicode.github.io/husky/)를 사용하면 보다 더 편리하게 git hook을 관리할 수 있다.\n\n# 🐶 husky\n\nhusky 는 Git Hooks 를 보다 쉽게 설정하고 관리할 수 있는 npm 모듈이다.\n\n## 설치\n\n쟈동으로 설치하는 방법이다. 수동으로 설치하고 싶다면 [🐶 husky](https://typicode.github.io/husky/) 공식 문서를 참조하자.\n\n```bash\n#npm을 사용할 때\nnpx husky-init && npm install\n\n#yarn을 사용할 때\nyarn dlx husky-init --yarn2 && yarn\n```\n\n설치를 진행하면 해당 디렉토리에 다음과 같은 폴더가 생성된 것을 확인할 수 있다. 또한 pre-commit이라는 훅이 자동적으로 생성된 것도 볼 수 있다.\n<img alt={\"git-hook-dir\"} style={{margin:\"20px auto 10px\"}} src={\"https://user-images.githubusercontent.com/56423604/276660300-5e0acbf4-ea3f-423d-aef9-3a85b4979a0b.png\"}/>\n생성된 hook을 살펴보면 commit 이전에 npm test를 실행하도록 설정되어 있는데 만일 필요없다면 지워줘도 무방하다.\n<img alt={\"husky-pre-commit\"} style={{margin:\"20px auto 10px\"}} src={\"https://user-images.githubusercontent.com/56423604/276660756-d9cc9040-b9cc-4eda-8b44-f6c9efb36620.png\"}/>\n`package.json` 에도 해당 스크립트가 자동으로 생성된 것을 확인할 수 있다.\n<img alt={\"package-husky-prepare\"} style={{margin:\"20px auto 10px\"}} src={\"https://user-images.githubusercontent.com/56423604/276661357-c225c9e6-74a3-4294-8218-43f44b193e92.png\"}/>\n\n## 적용\n\n스크립트를 적용하는 방법으로는 2가지 방법이 있다.\n\n1. 직접 파일 생성하고 작성하기\n\n파일이름을 훅 이름으로 생성하여 스크립트를 직접 작성하는 방법\n\n2. shell 명령어 사용하기\n\n ```bash\n npx husky add .husky/pre-commit \"npm test\"\n```\n\n# 직접 husky로 git hook 적용해보기\n\n<aside>\n  <strong>✅&nbsp;&nbsp;husky로 js 실행하고 생성 파일 prettier 적용하기</strong><br/><br/>\n  매 `commit` 전에 포스트 정보를 담은 `json` 파일을 생성하는 js 파일([관련 내용](https://coyo-hm.github.io/blog/post/git/git-commit-template))을 동작시키고 해당 json 파일에 prettier를 적용하여 `commit` 할 것 이다.\n</aside>\n\n## hook 생성하기\n\n우선 `package.json`에 table을 만드는 스크립트를 추가해주었다.\n\n```json\n\"scripts\": {\n    ...\n    \"prepare\": \"husky install\",\n    \"table\": \"node scripts/createPostTable.js\",\n    ...\n  },\n```\n\n그리고 나서 shell 창을 이용해서 다음 명령어를 입력해준다. commit message 생성 전에 실행하기 위해 `pre-commit`에 추가해 주었다.\n\n<img alt={\"shell-command-npm-table\"} style={{margin:\"20px auto 10px\"}} src={\"https://user-images.githubusercontent.com/56423604/276676938-cefe9b8c-57dc-40fc-881e-d4681450e2bd.png\"}/>\n\n그러면 pre-commit에 해당 명령어가 입력된 것을 확인할 수 있다.\n\n<img alt={\"husky-pre-commit-npm-table\"} style={{margin:\"20px auto 10px\"}} src={\"https://user-images.githubusercontent.com/56423604/276678444-914f78c5-e2b2-4066-9786-6f7ad39e52b7.png\"}/>\n\n이와 같은 방식으로 해당 폴더에 prettier를 실행하고 실행한 json 파일들을 git add 해주는 스크립트를 생성하고 이번에는 pre-commit에 명령어를 직접 입력해주었다.\n\n```json\n\"scripts\": {\n    ...\n    \"prepare\": \"husky install\",\n    \"table\": \"node scripts/createPostTable.js\",\n\t\t\"format\": \"prettier --cache --write public/static/table && git add -f public/static/table/\"\n    ...\n  },\n```\n\n<img alt={\"husky-pre-commit-npm-format\"} style={{margin:\"20px auto 10px\"}} src={\"https://user-images.githubusercontent.com/56423604/276679315-4e7ba008-e40b-436a-a7d6-48bd56290559.png\"}/>\n\n## 실행 결과\n\n실행 여부를 확인하기 위해 기존에 존재했던 public/static/table 폴더를 삭제해주었다.\n\n<img alt={\"before-commit\"} style={{margin:\"20px auto 10px\"}} src={\"https://user-images.githubusercontent.com/56423604/276680189-d886d35a-1eab-4bc0-952b-8438d378c5da.png\"}/>\n\ncommit을 실행한 후 commit 내역을 보면 json 파일들이 생성된 것을 확인할 수 있다.\n\n<img alt={\"commit-log\"} style={{margin:\"20px auto 10px\"}} src={\"https://user-images.githubusercontent.com/56423604/276682422-5cce1bda-4c1e-4640-aa23-a2a262ffeb51.png\"}/>\n\n\n# 참조\n\n- [훅으로 Git에 훅 들어가기](https://techblog.woowahan.com/2530/)\n- [husky 로 git hook 하자](https://library.gabia.com/contents/8492/)\n- [8.3 Customizing Git - Git Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)\n","fields":{"slug":"blog/post/husky-git-hook"},"path":"blog/husky-git-hook.mdx"}],"allTags":[{"tag":"all","count":23},{"tag":"javascript","count":9},{"tag":"react","count":8},{"tag":"typescript","count":6},{"tag":"network","count":4},{"tag":"git","count":3},{"tag":"css","count":2},{"tag":"redux","count":2},{"tag":"husky","count":2},{"tag":"axios","count":2},{"tag":"npm","count":1},{"tag":"yarn","count":1},{"tag":"yarn_berry","count":1},{"tag":"styled_components","count":1},{"tag":"redux_persist","count":1},{"tag":"lodash","count":1},{"tag":"python3","count":1},{"tag":"nextjs","count":1},{"tag":"commitlint","count":1},{"tag":"githubpage","count":1},{"tag":"intellij","count":1},{"tag":"emotion","count":1},{"tag":"gatsby","count":1},{"tag":"programming","count":1}],"category":"husky","page":0},"__N_SSG":true}