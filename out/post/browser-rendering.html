<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>COYO-LOG:D  | 브라우저 렌더링 과정 살펴보기</title><meta name="robots" content="index,follow"/><meta name="description" content="Rendering Engine 에 대해 알아보자"/><meta property="og:title" content="브라우저 렌더링 과정 살펴보기"/><meta property="og:description" content="Rendering Engine 에 대해 알아보자"/><meta property="og:url" content="https://coyo-hm.github.io/Post/browser-rendering"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2023-09-12T06:00:00.000Z"/><meta property="article:modified_time" content="2023-09-12T06:00:00.000Z"/><meta property="article:author" content="COYO"/><meta property="article:tag" content="network"/><meta property="article:tag" content="css"/><meta property="og:image" content="https://user-images.githubusercontent.com/56423604/272330679-3d6f37c2-fe0a-44f7-995a-8f600257b83f.png"/><meta property="og:image:alt" content="브라우저 렌더링 과정 살펴보기"/><link rel="canonical" href="https://coyo-hm.github.io/Post/browser-rendering"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","datePublished":"2023-09-12T06:00:00.000Z","description":"Rendering Engine 에 대해 알아보자","mainEntityOfPage":{"@type":"WebPage","@id":"https://coyo-hm.github.io/Post/browser-rendering"},"headline":"브라우저 렌더링 과정 살펴보기","image":["https://user-images.githubusercontent.com/56423604/272330679-3d6f37c2-fe0a-44f7-995a-8f600257b83f.png"],"dateModified":"2023-09-12T06:00:00.000Z","author":{"@type":"Person","name":"COYO"},"publisher":{"@type":"Organization","name":"COYO","logo":{"@type":"ImageObject","url":"https://coyo-hm.github.io//favicons/favicon-32x32.png"}}}</script><meta name="next-head-count" content="18"/><link rel="canonical" href="https://coyo-hm.github.io/"/><link rel="icon" href="/favicons/favicon.ico"/><link rel="apple-touch-icon" sizes="76x76" href="/favicons/logo_76x76.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/logo_32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/logo_16x16.png"/><link rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/558685b1c1de24fa.css" as="style"/><link rel="stylesheet" href="/_next/static/css/558685b1c1de24fa.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-91cbd5428e348355.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e724cec2f732fbd8.js" defer=""></script><script src="/_next/static/chunks/130-e223123549145b7d.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5B...slugs%5D-83c9f083a9cb9e84.js" defer=""></script><script src="/_next/static/rFuoPSN9d4mpMmZN1yJqz/_buildManifest.js" defer=""></script><script src="/_next/static/rFuoPSN9d4mpMmZN1yJqz/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-white dark:bg-neutral-800 text-neutral-800 dark:text-neutral-100 overflow-hidden mx-auto min-h-screen w-full"><div class="bg-transparent flex flex-col justify-center px-8 lg:w-[850px] m-auto min-h-screen"><header class="flex justify-end items-center pb-1 pt-5 relative h-12"><a class="text-lg italic font-extrabold mr-5 mt-1" href="/">COYO-LOG:D </a><nav class="flex grow gap-3 max-md:gap-2"><a class="hover:text-blue-700 font-light border-b italic border-b-blue-700" href="/post/page/0/all">BLOG</a><a class="hover:text-blue-700 font-light border-b italic border-b-transparent" href="/series/page/0">SERIES</a></nav><div class="grid gap-2 place-items-center"><button id="btn-theme" class="rounded-full bg-transparent text-yellow-500 dark:text-blue-100" aria-label="theme" type="button"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></svg></button></div></header><main class="w-full flex flex-col grow shrink"><article class="flex flex-col" id="post"><header class="pt-28 pb-14 text-5xl font-semibold text-center"><div class="italic text-center text-5xl font-bold break-keep max-md:text-xl leading-snug">브라우저 렌더링 과정 살펴보기</div><p class="text-sm text-neutral-500 mt-10">2023/9/12</p></header><div class="flex flex-row flex-nowrap relative border-y border-y-blue-700 max-md:flex-col-reverse"><div class="grow shrink pr-10 pt-5 min-w-0 max-md:p-0 max-md:pb-4"><p class="font-light text py-2">브라우저 렌더링에 대해 탐구해보자 그러기엔 우선 웹 브라우저 구조를 간단하게 살펴보자.</p>
<h1 class="font-extrabold text-2xl pt-8 pb-2 max-md:text-xl" id="웹브라우저구조"><a href="#웹-브라우저-구조" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>웹 브라우저 구조</h1>
<blockquote class="border-l-4 pl-3 my-2 border-neutral-600">
<p class="font-light text py-2">웹 브라우저</p>
<p class="font-light text py-2">코드(CSS, HTML, JavaScript 등등)를 가지고 웹 페이지를 그려주는 역할을 한다.</p>
</blockquote>
<img src="https://user-images.githubusercontent.com/56423604/268966576-73d71f41-92eb-4042-8dbf-78043990c7a2.png" alt="web-browser-structure" style="margin:20px 0"/>
<ul class="pl-3 my-2 ml-4 list-disc">
<li class="font-light text py-1 leading-6">
<p class="font-light text py-2">User Interface</p>
<p class="font-light text py-2">주소표시줄, 이전/다음/새로고침 버튼 등 웹페이지를 제외하고 사용자와 상호작용하는 사용자 인터페이스이다.</p>
</li>
<li class="font-light text py-1 leading-6">
<p class="font-light text py-2">Browser Engine</p>
<p class="font-light text py-2">유저인터페이스와 렌더링 엔진을 연결하는 브라우저 엔진</p>
</li>
<li class="font-light text py-1 leading-6">
<p class="font-light text py-2">Rendering Engine</p>
<p class="font-light text py-2">HTML과 CSS를 파싱하여 요청하는 웹 페이지를 표시하는 렌더링 엔진</p>
</li>
<li class="font-light text py-1 leading-6">
<p class="font-light text py-2">Networking</p>
<p class="font-light text py-2">각종 네트워크 요청을 수행하는 네트워킹 파트</p>
</li>
<li class="font-light text py-1 leading-6">
<p class="font-light text py-2">JavaScript Interpreter</p>
<p class="font-light text py-2">자바스크립트 코드를 실행하는 인터프리터 (크롬의 경우 V8을 사용하는 엔진)</p>
</li>
<li class="font-light text py-1 leading-6">
<p class="font-light text py-2">UI Backend</p>
<p class="font-light text py-2">체크박스나 버튼과 같은 기본적인 위젯을 그려주는 UI Backend 파트</p>
</li>
<li class="font-light text py-1 leading-6">
<p class="font-light text py-2">Data Science</p>
<p class="font-light text py-2">localStorage나 Cookie와 같이 보조 기억 장치에 데이터를 저장하는 파트</p>
</li>
</ul>
<h1 class="font-extrabold text-2xl pt-8 pb-2 max-md:text-xl" id="RenderingEngine"><a href="#rendering-engine" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>Rendering Engine</h1>
<aside><p class="text">💡  웹 브라우저마다 렌더링 엔진이 다르다</p><ul class="pl-3 my-2 ml-4 list-disc">
<li class="font-light text py-1 leading-6">Chrome은 Blink, 신형 Edge</li>
<li class="font-light text py-1 leading-6">Safari는 Webkit</li>
<li class="font-light text py-1 leading-6">Firefox는 Gecko</li>
<li class="font-light text py-1 leading-6">Trident은 IE</li>
</ul></aside>
<h2 class="font-extrabold text-xl pt-8 pb-2 max-md:text-lg" id="RenderingEngine의역할"><a href="#rendering-engine의-역할" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>Rendering Engine의 역할</h2>
<p class="font-light text py-2">✔️ HTML, CSS, JS, 이미지 등 웹페이지에 포함된 모든 요소들을 화면에 보여준다.</p>
<p class="font-light text py-2">✔️ 업데이트<span style="color:rgb(163 163 163)">(사용자 동작으로 인해서 입력이 발생한다던가, 스크롤이 생겼다던가 등의 업데이트)</span>가 필요할 때, 효율적으로 렌더링을 할 수 있도록 자료 구조를 생성한다.</p>
<h2 class="font-extrabold text-xl pt-8 pb-2 max-md:text-lg" id="RenderingEngine의동작과정CriticalRenderingPath(CRP)"><a href="#rendering-engine의-동작-과정-critical-rendering-pathcrp" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>Rendering Engine의 동작 과정: Critical Rendering Path(CRP)</h2>
<p class="font-light text py-2">브라우저가 페이지의 초기 출력을 위해 실행해야 하는 순서</p>
<img width="1685" style="margin:20px 0" alt="rendering-engine" src="https://github.com/COYO-HM/COYO-HM.github.io/assets/56423604/e7ec1ccb-2414-4f31-851a-a8a3c7b5a37f"/>
<img style="margin:20px 0 5px" alt="renderer-process" src="https://user-images.githubusercontent.com/56423604/268993997-6460af95-26ae-4798-a1da-d9f008ebabc6.png"/>
<div style="color:rgb(163 163 163);font-size:12px;margin:0 0 15px">이미지 출처: <a href="https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit#heading=h.v5plba74lfde" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">Blink의 Renderer Process</a></div>
<h3 class="font-extrabold pt-6 pb-2 text-lg max-md:text" id="1DOMTree와CSSOMTree의생성"><a href="#1-dom-tree와-cssom-tree의-생성" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>1. DOM Tree와 CSSOM Tree의 생성</h3>
<p class="font-light text py-2">먼저 브라우저에서 사용자가 요청한 웹페이지에 문서를 불러오고 HTML tag들을 토큰화(Tokenizer)한다.</p>
<p class="font-light text py-2">토큰화한 후에 브라우저가 렉싱(Lexing) 과정을 통해 토큰을 해당 속성과 규칙을 정의하는 노드 객체로 변환한다.</p>
<p class="font-light text py-2">파싱(Parsing) 과정을 통해 각 노드가 서로 연관성을 가질 수 있도록 트리를 생성한다 ⇒ DOM Tree 생성</p>
<p class="font-light text py-2">HTML 문서에 잇는 모든 것들은 DOM을 구성한다.</p>
<p class="font-light text py-2">최상위에는 <code class="">document</code> 객체가 들어가고 태그는 element node(html)가 되고 태그의 요소는 attribute node, text node가 되어 트리 구조로 생성한다(이외에도 주석은 comment node가 되어 생성된다).</p>
<img style="margin:20px 0 5px" alt="Constructing-the-Object-Model" src="https://user-images.githubusercontent.com/56423604/269012635-a403bf07-45b5-43ef-9c4a-996671ed7693.png"/>
<div style="color:rgb(163 163 163);font-size:12px;margin:0 0 15px">이미지 출처: <a href="https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit#heading=h.v5plba74lfde" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">Blink의 Renderer Process</a></div>
<p class="font-light text py-2">HTML을 DOM 트리로 만드는 과정과 비슷하게 CSS의 경우 CSSOM Tree가 만들어진다. <br/>DOM 생성하는 동안 CSS 스타일시트 링크 태그를 접하고 리소스에 대해 요청한다.</p>
<p class="font-light text py-2">CSS도 브라우저가 이해하고 처리할 수 있도록 CSSOM Tree로 변환한다.<br/>CSSOM은 DOM이 어떻게 화면에 표시될 지를 알려주는 역할을 한다.</p>
<img style="margin:20px 0" alt="CSSOM" src="https://user-images.githubusercontent.com/56423604/269015530-9fd4cab4-6050-4ed4-a5b3-90c6cdc45d41.png"/>
<img style="margin:0 0 5px" alt="CSSOM" src="https://user-images.githubusercontent.com/56423604/269018447-1195e2fe-e57e-4128-8565-d1679fb2e260.png"/>
<div style="color:rgb(163 163 163);font-size:12px;margin:0 0 15px">이미지 출처: <a href="https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit#heading=h.v5plba74lfde" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">Blink의 Renderer Process</a></div>
<h3 class="font-extrabold pt-6 pb-2 text-lg max-md:text" id="2RenderTree생성"><a href="#2-render-tree-생성" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>2. Render Tree 생성</h3>
<aside><p class="text-lg">📖  Render Tree</p><ul class="pl-3 my-2 ml-4 list-disc">
<li class="font-light text py-1 leading-6">렌더링 엔진이 DOM Tree와 CSSOM Tree를 합쳐서 만든 트리</li>
<li class="font-light text py-1 leading-6">화면에 표시되어야 할 모든 노드의 컨텐츠, 스타일 정보를 포함하는 트리</li>
</ul></aside>
<p class="font-light text py-2">document 객체부터 각 노드를 순회하면서 각각의 맞는 CSSOM를 찾아서 규칙을 적용하며 렌더와 관련된 요소들을 렌더 트리에 포함시킨다.</p>
<p class="font-light text py-2">이 때, <code class="">meta tag</code>나 <code class="">display: none</code> 속성을 가진 요소들은 렌더와 관계가 없기에 렌더 트리에 포함되지 않는다.</p>
<img style="margin:20px 0 5px" alt="Render_Tree_Construction_Layout_and_Paint" src="https://user-images.githubusercontent.com/56423604/269020715-b0948780-e34b-4b57-b809-8e78fd6c0c38.png"/>
<div style="color:rgb(163 163 163);font-size:12px;margin:0 0 15px">이미지 출처: <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">[Critical Rendering Path] Render-Tree Construction, Layout, and Paint</a></div>
<h3 class="font-extrabold pt-6 pb-2 text-lg max-md:text" id="3RenderTree배치Layout(Reflow)"><a href="#3-render-tree-배치-layoutreflow" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>3. Render Tree 배치: Layout(Reflow)</h3>
<p class="font-light text py-2">Render Tree 가 생성되면 Layout(Reflow)이라는 과정을 거친다. viewport 내에서 요소들에 정확한 위치와 크기를 (모든 스타일 속성이) 계산하는 과정이다.</p>
<p class="font-light text py-2">이때 <code class="">%</code>, <code class="">em</code>과 같은 상대적인 단위를 사용했을 때는 viewport 에 맞춰서 픽셀단위로 변환된다.</p>
<h3 class="font-extrabold pt-6 pb-2 text-lg max-md:text" id="4RenderTree그리기Paint(Repaint)"><a href="#4-render-tree-그리기-paintrepaint" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>4. Render Tree 그리기: Paint(Repaint)</h3>
<p class="font-light text py-2">렌더링 엔진이 각 요소들이 실제로 그려지는 과정이다.</p>
<h1 class="font-extrabold text-2xl pt-8 pb-2 max-md:text-xl" id="UI가업데이트되는3가지상황"><a href="#ui가-업데이트-되는-3가지-상황" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>UI가 업데이트 되는 3가지 상황</h1>
<p class="font-light text py-2">위에는 브라우저가 페이지의 초기 출력을 위해 실행해야 하는 순서라면, UI가 사용자와의 상호작용 통해 업데이트 경우가 존재한다.
과정이 1 &lt; 2&lt; 3 순으로 적기에 높은 숫자일수록 성능이 우수하다.</p>
<h2 class="font-extrabold text-xl pt-8 pb-2 max-md:text-lg" id="1Layout이다시발생하는경우"><a href="#1-layout-이-다시-발생하는-경우" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>1. Layout 이 다시 발생하는 경우</h2>
<span style="font-size:18px;font-weight:700">: JavaScript → Style → Layout → Paint → Composite</span>
<ul class="pl-3 my-2 ml-4 list-disc">
<li class="font-light text py-1 leading-6">주로 요소의 크기나 위치가 바뀔 때, 혹은 브라우저 창의 크기가 바뀌었을 때 다시 발생</li>
<li class="font-light text py-1 leading-6">이 때, 레이아웃 수치를 다시 계산해서 재배치 해야 하기에 레이아웃 과정과 페인트, 레이어 합성 과정이 다시 발생한다.</li>
</ul>
<h2 class="font-extrabold text-xl pt-8 pb-2 max-md:text-lg" id="2Paint부터다시발생하는경우"><a href="#2-paint-부터-다시-발생하는-경우" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>2. Paint 부터 다시 발생하는 경우</h2>
<span style="font-size:18px;font-weight:700">: JavaScript → Style → Paint → Composite</span>
<ul class="pl-3 my-2 ml-4 list-disc">
<li class="font-light text py-1 leading-6">주로 배경 이미지나 텍스트 색상, 그림자 등 레이아웃의 수치를 변화시키지 않는 스타일의 변경이 일어났을 경우 발생</li>
<li class="font-light text py-1 leading-6">레이아웃이 변경되지 않기에 성능적으로 1번보다 더욱 우수</li>
</ul>
<h2 class="font-extrabold text-xl pt-8 pb-2 max-md:text-lg" id="3레이어의합성(Composite)만다시발생하는경우"><a href="#3-레이어의-합성composite만-다시-발생하는-경우" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>3. 레이어의 합성(Composite)만 다시 발생하는 경우</h2>
<span style="font-size:18px;font-weight:700">: JavaScript → Style → Composite</span>
<ul class="pl-3 my-2 ml-4 list-disc">
<li class="font-light text py-1 leading-6">Layout과 Paint를 수행하지 않고 레이어의 합성만 발생하기에 성능적으로 가장 우수한 케이스이다.</li>
<li class="font-light text py-1 leading-6">레이어란 페인팅할 영역을 나누어 놓는 것을 의미한다. 크롬의 경우에는 Layout 과정 이후에 정해진 기준이나 필요에 의해 브라우저가 레이어를 생성한다.</li>
<li class="font-light text py-1 leading-6">렌더 트리에 있는 노드 객체들은 생성된 레이어에 포함된다. 레이어들은 트리 형태 구성된다.<br/>
→ 렌더링 엔진이 각 레이어를 프린팅 과정에서 각각 그려 준 다음에 하나의 비트맵으로 합성하여 페이지를 완성한다.</li>
</ul>
<p class="font-light text py-2">아래의 사이트에서 CSS 속성마다 렌더링 엔진별로 UI가 어떻게 업데이트 되는지 알 수 있다.</p>
<a href="https://csstriggers.com/" target="_blank" style="cursor:pointer"><img width="400" style="margin:20px auto" alt="css-Triggers-List-2" src="https://user-images.githubusercontent.com/56423604/269030495-c1f213be-82eb-423b-a80d-20858694b7de.png"/></a>
<h1 class="font-extrabold text-2xl pt-8 pb-2 max-md:text-xl" id="개발자도구로리렌더과정살펴보기"><a href="#개발자-도구로-리렌더-과정-살펴-보기" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>개발자 도구로 리렌더 과정 살펴 보기</h1>
<p class="font-light text py-2">실습은 해당 사이트에서 진행되었습니다. : <a href="https://coyo-hm.github.io/rendering_engine_practice/" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">Rendering Engine Practice</a></p>
<h2 class="font-extrabold text-xl pt-8 pb-2 max-md:text-lg" id="alignitems를변경하는경우"><a href="#align-items-를-변경하는-경우" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>align-items 를 변경하는 경우</h2>
<img style="margin:20px 0 5px" alt="cssom-align-items" src="https://user-images.githubusercontent.com/56423604/269034349-fb2298eb-12cc-481b-b0c0-f40eaaf4577c.png"/>
<div style="color:rgb(163 163 163);font-size:12px;margin:0 0 15px">이미지 출처: <a href="https://csstriggers.com/" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">CSS Triggers List – What Kind of Changes You Can Make</a></div>
<ul class="pl-3 my-2 ml-4 list-disc">
<li class="font-light text py-1 leading-6">Blink</li>
</ul>
<p class="font-light text py-2">CSS Triggers 에 따르면, Blink 기준으로 Layout 부터 다시 발생(: JavaScript → Style → Layout → Paint → Composite)한다.</p>
<img style="margin:20px 0" alt="blink-align-items" src="https://user-images.githubusercontent.com/56423604/269039092-99232f88-01cf-4cd6-ae7e-805200bb5c47.png"/>
<p class="font-light text py-2">개발자 도구 performance 탭을 살펴보면 Recalculate → Layout → Pre Paint → Paint → Layerize → Commit 순서로 렌더링 되었음을 확인할 수 있다.</p>
<h2 class="font-extrabold text-xl pt-8 pb-2 max-md:text-lg" id="borderrightcolor을변경하는경우"><a href="#border-right-color-을-변경하는-경우" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>border-right-color 을 변경하는 경우</h2>
<img style="margin:20px 0 5px" alt="cssom-border-right-color" src="https://user-images.githubusercontent.com/56423604/269040996-650204fc-3c75-4da8-b1d5-7ea6aa7ff5f0.png"/>
<div style="color:rgb(163 163 163);font-size:12px;margin:0 0 15px">이미지 출처: <a href="https://csstriggers.com/" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">CSS Triggers List – What Kind of Changes You Can Make</a></div>
<ul class="pl-3 my-2 ml-4 list-disc">
<li class="font-light text py-1 leading-6">
<p class="font-light text py-2">Blink</p>
<p class="font-light text py-2"><code class="">border-right-color</code>를 바꾸는 경우에는 위의 설명에도 나와 있고 CSS Triggers 에서도 Blink 기준으로 Paint 부터 다시 발생(: JavaScript → Style → Paint → Composite)하는 것을 알 수 있다.</p>
</li>
</ul>
<img style="margin:20px 0" alt="blink-border-right-color" src="https://user-images.githubusercontent.com/56423604/269042941-cf22c84c-0d19-4655-af70-70ce9ec34b36.png"/>
<h2 class="font-extrabold text-xl pt-8 pb-2 max-md:text-lg" id="backgroundcolor을변경하는경우"><a href="#background-color-을-변경하는-경우" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>background-color 을 변경하는 경우</h2>
<img style="margin:20px 0 5px" alt="cssom-background-color" src="https://user-images.githubusercontent.com/56423604/269041943-6ed739dd-3d9d-4737-9aa1-390f1ff09a1c.png"/>
<div style="color:rgb(163 163 163);font-size:12px;margin:0 0 15px">이미지 출처: <a href="https://csstriggers.com/" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">CSS Triggers List – What Kind of Changes You Can Make</a></div>
<ul class="pl-3 my-2 ml-4 list-disc">
<li class="font-light text py-1 leading-6">
<p class="font-light text py-2">Blink</p>
<p class="font-light text py-2"><code class="">background-color</code>를 바꾸는 경우에는 위의 설명에도 나와 있고 CSS Triggers 에서도 Blink 기준으로 Paint 부터 다시 발생(: JavaScript → Style → Paint → Composite)하는 것을 알 수 있다.</p>
</li>
</ul>
<img style="margin:20px 0" alt="blink-border-right-color" src="https://user-images.githubusercontent.com/56423604/269042941-cf22c84c-0d19-4655-af70-70ce9ec34b36.png"/>
<h2 class="font-extrabold text-xl pt-8 pb-2 max-md:text-lg" id="opacity를변경하는경우"><a href="#opacity-를-변경하는-경우" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>opacity 를 변경하는 경우</h2>
<img style="margin:20px 0 5px" alt="cssom-opacity" src="https://user-images.githubusercontent.com/56423604/269042111-bb3c95ca-2874-4677-81f1-26569fc269de.png"/>
<div style="color:rgb(163 163 163);font-size:12px;margin:0 0 15px">이미지 출처: <a href="https://blinders.tistory.com/93" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">[CSS] opacity는 reflow가 발생 안 한다구요...? 정말??</a></div>
<p class="font-light text py-2">CSS Triggers 에 따르면, Blink 기준으로 Paint 부터 다시 발생(: JavaScript → Style → Paint → Composite)한다.</p>
<p class="font-light text py-2">그런데 처음에 <code class="">opacity</code>를 기본값인 1에서 0으로 변하고 1로 변할때 layout 과정이 발생한 것을 발견할 수 있었다.</p>
<img style="margin:20px 0" alt="blink-opcity2" src="https://user-images.githubusercontent.com/56423604/269047824-78cadf35-afc2-4743-b7c6-20c7a9807ecb.png"/>
<p class="font-light text py-2">이에 대해 찾아보니 위에서 말했듯이 브라우저가 코드를 렌더링하기 위해서는 HTML를 파싱하여 DOM Tree를 구성하고 DOM Tree와 CSSOM Tree를 하나로 합쳐 Render Tree로 만들고, 그 Render Tree를 바탕으로 Layer(레이어)를 구성한다.</p>
<p class="font-light text py-2">이때 이 레이어가 실제 포토샵에서 쓰는 레이어와 비슷한 의미의 언어로 층을 의미하는데, 브라우저는 레이어를 쌓아가며 화면을 구성하여 우리에게 보여준다. 앞에 레이어에 가려진 것을 뿐 뒤에 레이어에도 엄연히 화면이 그려진 3차원이라고 볼 수 있다.
이를 <a href="https://developer.mozilla.org/ko/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline"><code class="">Stacking Context</code></a>라고 하며 MDN에서는 <code class="">가상의 Z축을 사용한 HTML 요소의 3차원 개념화</code>이라고 한다.각각의 HTML 요소는 자신의 속성에 따른 우선순위를 사용해 3차원 공간을 차지한다.</p>
<p class="font-light text py-2"><code class="">Stacking Context</code>는 조건에 따라 <code class="">document</code> 어디에서나 다음 조건을 만족하는 element가 생성된다.</p>
<ul class="pl-3 my-2 ml-4 list-disc">
<li class="font-light text py-1 leading-6">document의 root element. (<code class="">&lt;html&gt;</code>)</li>
<li class="font-light text py-1 leading-6">position이 absolute 또는 relative이고, z-index가 auto가 아닌 요소.</li>
<li class="font-light text py-1 leading-6">position이 fixed 또는 sticky인 요소. (sticky는 모든 모바일 브라우저에서는 해당하지만 구형 데스크톱 브라우저에서는 해당하지 않음)</li>
<li class="font-light text py-1 leading-6">플렉스(flexbox (en-US)) 컨테이너의 자식 중 z-index가 auto가 아닌 요소.</li>
<li class="font-light text py-1 leading-6">그리드(grid (en-US)) 컨테이너의 자식 중 z-index가 auto가 아닌 요소.</li>
<li class="font-light text py-1 leading-6">opacity가 1보다 작은 요소. (불투명도 명세 참고)</li>
<li class="font-light text py-1 leading-6">mix-blend-mode가 normal이 아닌 요소.</li>
<li class="font-light text py-1 leading-6">다음 속성 중 하나라도 none이 아닌 값을 가진 요소.<!-- -->
<ul class="pl-3 my-2 ml-4 list-disc">
<li class="font-light text py-1 leading-6">transform</li>
<li class="font-light text py-1 leading-6">filter</li>
<li class="font-light text py-1 leading-6">perspective (en-US)</li>
<li class="font-light text py-1 leading-6">clip-path</li>
<li class="font-light text py-1 leading-6">mask / mask-image (en-US) / mask-border (en-US)</li>
</ul>
</li>
<li class="font-light text py-1 leading-6">isolation이 isolate인 요소.</li>
<li class="font-light text py-1 leading-6">-webkit-overflow-scrolling이 touch인 요소.</li>
<li class="font-light text py-1 leading-6">will-change의 값으로, 초깃값이 아닐 때 새로운 쌓임 맥락을 생성하는 속성을 지정한 요소.</li>
<li class="font-light text py-1 leading-6">contain이 layout, paint, 또는 둘 중 하나를 포함하는 값(strict, content 등)인 요소.</li>
</ul>
<p class="font-light text py-2">우리는 여기서 <code class="">* opacity가 1보다 작은 요소. (불투명도 명세 참고)</code> 요 부분에 주목할 필요가 있다.
설정한 에니메이션에서는 기본값인 opacity 1에서 0으로 변화했다가 다시 1로 변화했기에 해당 요소가 별도의 레이어를 가졌다는 것을 알 수 있다.
그래서 레이아웃 과정부터 요소들을 재계산하고 레이어를 생성하여 재배치해줄 과정이 필요한 것이다.</p>
<p class="font-light text py-2">그래서 처음부터 opacity 값을 1보다 작은 0.99로 주고 0으로 변한 후 다시 0.99로 돌아왔을 경우에는 다음과 같이 우리가 원했던 Paint 부터 시작되는 것을 볼 수 있었다.</p>
<img style="margin:20px 0" alt="blink-opcity1" src="https://user-images.githubusercontent.com/56423604/269052188-a640204a-4c53-405f-aade-aefa052dede6.png"/>
<h1 class="font-extrabold text-2xl pt-8 pb-2 max-md:text-xl" id="참조"><a href="#참조" aria-hidden="true" tabindex="-1" class="underline"><span class="icon icon-link"></span></a>참조</h1>
<ul class="pl-3 my-2 ml-4 list-disc">
<li class="font-light text py-1 leading-6"><a href="https://www.youtube.com/watch?v=sJ14cWjrNis" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">[10분 테코톡] ☕️ 체프의 브라우저 렌더링</a></li>
<li class="font-light text py-1 leading-6"><a href="https://hyojin96.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95-Render-Tree%EC%99%80-DOM-Tree%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">브라우저의 렌더링 과정 &amp; Render Tree와 DOM Tree의 차이점</a></li>
<li class="font-light text py-1 leading-6"><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">[Critical Rendering Path] Render-Tree Construction, Layout, and Paint</a></li>
<li class="font-light text py-1 leading-6"><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">Constructing the Object Model</a></li>
<li class="font-light text py-1 leading-6"><a href="https://web.dev/critical-rendering-path-render-tree-construction/?hl=ko" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">Render-tree Construction, Layout, and Paint</a></li>
<li class="font-light text py-1 leading-6"><a href="https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit#heading=h.v5plba74lfde" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">Blink의 Renderer Process</a></li>
<li class="font-light text py-1 leading-6"><a href="https://blinders.tistory.com/93" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">[CSS] opacity는 reflow가 발생 안 한다구요...? 정말??</a></li>
<li class="font-light text py-1 leading-6"><a href="https://developer.mozilla.org/ko/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context" target="_blank" rel="noreferrer" class="hover:text-blue-700 underline">[MDN] Stacking Context</a></li>
</ul><div class="pt-4 flex flex-row items-center flex-wrap"><h1 class="text-lg mr-3 mb-2 italic font-semibold">#tags</h1><a class="mr-2 mb-2 h-6 p-1 w-fit break-keep text-xs rounded bg-neutral-100 dark:bg-neutral-700 hover:text-white hover:bg-blue-700 dark:hover:bg-blue-700" href="/post/page/0/network">#<!-- -->Network</a><a class="mr-2 mb-2 h-6 p-1 w-fit break-keep text-xs rounded bg-neutral-100 dark:bg-neutral-700 hover:text-white hover:bg-[#1572b6] dark:hover:bg-[#1572b6]" href="/post/page/0/css">#<!-- -->CSS</a></div></div><div class="w-52 shrink-0 h-full top-0 py-[50px] sticky flex flex-col flex-nowrap justify-center items-center max-md:static max-md:h-fit max-md:w-full"><button class="hover:text-blue-700 max-md:hidden"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" height="32" width="32" xmlns="http://www.w3.org/2000/svg"><path d="M240.971 130.524l194.343 194.343c9.373 9.373 9.373 24.569 0 33.941l-22.667 22.667c-9.357 9.357-24.522 9.375-33.901.04L224 227.495 69.255 381.516c-9.379 9.335-24.544 9.317-33.901-.04l-22.667-22.667c-9.373-9.373-9.373-24.569 0-33.941L207.03 130.525c9.372-9.373 24.568-9.373 33.941-.001z"></path></svg></button><div id="toc" class="w-full flex flex-col border-l-2 border-l-blue-100 dark:border-l-blue-900 my-4 rounded-none max-md:border-0 max-md:p-4 max-md:bg-neutral-200 max-md:rounded-xl dark:bg-neutral-700"><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-1" href="/post/browser-rendering#%EC%9B%B9%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EA%B5%AC%EC%A1%B0">웹 브라우저 구조</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-1" href="/post/browser-rendering#RenderingEngine">Rendering Engine</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-2" href="/post/browser-rendering#RenderingEngine%EC%9D%98%EC%97%AD%ED%95%A0">Rendering Engine의 역할</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-2" href="/post/browser-rendering#RenderingEngine%EC%9D%98%EB%8F%99%EC%9E%91%EA%B3%BC%EC%A0%95CriticalRenderingPath(CRP)">Rendering Engine의 동작 과정: Critical Rendering Path(CRP)</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-3" href="/post/browser-rendering#1DOMTree%EC%99%80CSSOMTree%EC%9D%98%EC%83%9D%EC%84%B1">1. DOM Tree와 CSSOM Tree의 생성</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-3" href="/post/browser-rendering#2RenderTree%EC%83%9D%EC%84%B1">2. Render Tree 생성</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-3" href="/post/browser-rendering#3RenderTree%EB%B0%B0%EC%B9%98Layout(Reflow)">3. Render Tree 배치: Layout(Reflow)</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-3" href="/post/browser-rendering#4RenderTree%EA%B7%B8%EB%A6%AC%EA%B8%B0Paint(Repaint)">4. Render Tree 그리기: Paint(Repaint)</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-1" href="/post/browser-rendering#UI%EA%B0%80%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%90%98%EB%8A%943%EA%B0%80%EC%A7%80%EC%83%81%ED%99%A9">UI가 업데이트 되는 3가지 상황</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-2" href="/post/browser-rendering#1Layout%EC%9D%B4%EB%8B%A4%EC%8B%9C%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94%EA%B2%BD%EC%9A%B0">1. Layout 이 다시 발생하는 경우</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-2" href="/post/browser-rendering#2Paint%EB%B6%80%ED%84%B0%EB%8B%A4%EC%8B%9C%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94%EA%B2%BD%EC%9A%B0">2. Paint 부터 다시 발생하는 경우</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-2" href="/post/browser-rendering#3%EB%A0%88%EC%9D%B4%EC%96%B4%EC%9D%98%ED%95%A9%EC%84%B1(Composite)%EB%A7%8C%EB%8B%A4%EC%8B%9C%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94%EA%B2%BD%EC%9A%B0">3. 레이어의 합성(Composite)만 다시 발생하는 경우</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-1" href="/post/browser-rendering#%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%8F%84%EA%B5%AC%EB%A1%9C%EB%A6%AC%EB%A0%8C%EB%8D%94%EA%B3%BC%EC%A0%95%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0">개발자 도구로 리렌더 과정 살펴 보기</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-2" href="/post/browser-rendering#alignitems%EB%A5%BC%EB%B3%80%EA%B2%BD%ED%95%98%EB%8A%94%EA%B2%BD%EC%9A%B0">align-items 를 변경하는 경우</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-2" href="/post/browser-rendering#borderrightcolor%EC%9D%84%EB%B3%80%EA%B2%BD%ED%95%98%EB%8A%94%EA%B2%BD%EC%9A%B0">border-right-color 을 변경하는 경우</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-2" href="/post/browser-rendering#backgroundcolor%EC%9D%84%EB%B3%80%EA%B2%BD%ED%95%98%EB%8A%94%EA%B2%BD%EC%9A%B0">background-color 을 변경하는 경우</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-2" href="/post/browser-rendering#opacity%EB%A5%BC%EB%B3%80%EA%B2%BD%ED%95%98%EB%8A%94%EA%B2%BD%EC%9A%B0">opacity 를 변경하는 경우</a><a class="hover:text-blue-700 box-decoration-slice py-1.5 pr-1 text-xs  header-1" href="/post/browser-rendering#%EC%B0%B8%EC%A1%B0">참조</a></div><button><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="hover:text-blue-700 max-md:hidden" height="32" width="32" xmlns="http://www.w3.org/2000/svg"><path d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"></path></svg></button></div></div><div id="utterances-light"></div><div id="utterances-dark"></div></article></main><footer class="flex flex-col items-center pb-7 text-neutral-700 dark:text-neutral-500"><div class="flex justify-center mb-2"><a href="https://github.com/COYO-HM" target="_blank" rel="noreferrer" class="mr-4 hover:text-blue-700"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a href="mailto:bsydwp@gmail.com" class="hover:text-blue-700"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path></svg></a></div><div class="col-span-2 font-extralight">© 2021 - 2023 COYO All rights reserved.</div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"frontMatter":{"date":"2023-09-12T15:00:00","title":"브라우저 렌더링 과정 살펴보기","tags":["network","css"],"description":"Rendering Engine 에 대해 알아보자","published":true,"thumbnail":"https://user-images.githubusercontent.com/56423604/272330679-3d6f37c2-fe0a-44f7-995a-8f600257b83f.png"},"body":"브라우저 렌더링에 대해 탐구해보자 그러기엔 우선 웹 브라우저 구조를 간단하게 살펴보자.\n\n# 웹 브라우저 구조\n\n\u003e 웹 브라우저\n\u003e\n\u003e 코드(CSS, HTML, JavaScript 등등)를 가지고 웹 페이지를 그려주는 역할을 한다.\n\n\u003cimg src={\"https://user-images.githubusercontent.com/56423604/268966576-73d71f41-92eb-4042-8dbf-78043990c7a2.png\"} alt={\"web-browser-structure\"} style={{margin:\"20px 0\"}}/\u003e\n\n* User Interface\n\n    주소표시줄, 이전/다음/새로고침 버튼 등 웹페이지를 제외하고 사용자와 상호작용하는 사용자 인터페이스이다.\n\n* Browser Engine\n\n    유저인터페이스와 렌더링 엔진을 연결하는 브라우저 엔진\n\n* Rendering Engine\n\n    HTML과 CSS를 파싱하여 요청하는 웹 페이지를 표시하는 렌더링 엔진\n\n* Networking\n\n    각종 네트워크 요청을 수행하는 네트워킹 파트\n\n* JavaScript Interpreter\n\n    자바스크립트 코드를 실행하는 인터프리터 (크롬의 경우 V8을 사용하는 엔진)\n\n* UI Backend\n\n    체크박스나 버튼과 같은 기본적인 위젯을 그려주는 UI Backend 파트\n\n* Data Science\n\n    localStorage나 Cookie와 같이 보조 기억 장치에 데이터를 저장하는 파트\n\n\n# Rendering Engine\n\n\u003caside\u003e\n  \u003cp className={\"text\"}\u003e💡\u0026nbsp;\u0026nbsp;웹 브라우저마다 렌더링 엔진이 다르다\u003c/p\u003e\n  * Chrome은 Blink, 신형 Edge\n  * Safari는 Webkit\n  * Firefox는 Gecko\n  * Trident은 IE\n\u003c/aside\u003e\n\n## Rendering Engine의 역할\n✔️ HTML, CSS, JS, 이미지 등 웹페이지에 포함된 모든 요소들을 화면에 보여준다.\n\n✔️ 업데이트\u003cspan style={{color: \"rgb(163 163 163)\"}}\u003e(사용자 동작으로 인해서 입력이 발생한다던가, 스크롤이 생겼다던가 등의 업데이트)\u003c/span\u003e가 필요할 때, 효율적으로 렌더링을 할 수 있도록 자료 구조를 생성한다.\n\n## Rendering Engine의 동작 과정: Critical Rendering Path(CRP)\n\n브라우저가 페이지의 초기 출력을 위해 실행해야 하는 순서\n\n\u003cimg width=\"1685\" style={{margin:\"20px 0\"}} alt=\"rendering-engine\" src=\"https://github.com/COYO-HM/COYO-HM.github.io/assets/56423604/e7ec1ccb-2414-4f31-851a-a8a3c7b5a37f\"/\u003e\n\n\n\u003cimg style={{margin:\"20px 0 5px\"}} alt={\"renderer-process\"} src={\"https://user-images.githubusercontent.com/56423604/268993997-6460af95-26ae-4798-a1da-d9f008ebabc6.png\"}/\u003e\n  \u003cdiv style={{color: \"rgb(163 163 163)\", fontSize:\"12px\", margin: \"0 0 15px\"}}\u003e이미지 출처: [Blink의 Renderer Process](https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit#heading=h.v5plba74lfde)\u003c/div\u003e\n\n### 1. DOM Tree와 CSSOM Tree의 생성\n\n먼저 브라우저에서 사용자가 요청한 웹페이지에 문서를 불러오고 HTML tag들을 토큰화(Tokenizer)한다.\n\n토큰화한 후에 브라우저가 렉싱(Lexing) 과정을 통해 토큰을 해당 속성과 규칙을 정의하는 노드 객체로 변환한다.\n\n파싱(Parsing) 과정을 통해 각 노드가 서로 연관성을 가질 수 있도록 트리를 생성한다 ⇒ DOM Tree 생성\n\nHTML 문서에 잇는 모든 것들은 DOM을 구성한다.\n\n최상위에는 `document` 객체가 들어가고 태그는 element node(html)가 되고 태그의 요소는 attribute node, text node가 되어 트리 구조로 생성한다(이외에도 주석은 comment node가 되어 생성된다).\n\n\u003cimg style={{margin:\"20px 0 5px\"}} alt={\"Constructing-the-Object-Model\"} src={\"https://user-images.githubusercontent.com/56423604/269012635-a403bf07-45b5-43ef-9c4a-996671ed7693.png\"}/\u003e\n  \u003cdiv style={{color: \"rgb(163 163 163)\", fontSize:\"12px\", margin: \"0 0 15px\"}}\u003e이미지 출처: [Blink의 Renderer Process](https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit#heading=h.v5plba74lfde)\u003c/div\u003e\n\nHTML을 DOM 트리로 만드는 과정과 비슷하게 CSS의 경우 CSSOM Tree가 만들어진다. \u003cbr/\u003eDOM 생성하는 동안 CSS 스타일시트 링크 태그를 접하고 리소스에 대해 요청한다.\n\nCSS도 브라우저가 이해하고 처리할 수 있도록 CSSOM Tree로 변환한다.\u003cbr/\u003eCSSOM은 DOM이 어떻게 화면에 표시될 지를 알려주는 역할을 한다.\n\n\u003cimg style={{margin:\"20px 0\"}} alt={\"CSSOM\"} src={\"https://user-images.githubusercontent.com/56423604/269015530-9fd4cab4-6050-4ed4-a5b3-90c6cdc45d41.png\"}/\u003e\n\u003cimg style={{margin:\"0 0 5px\"}} alt={\"CSSOM\"} src={\"https://user-images.githubusercontent.com/56423604/269018447-1195e2fe-e57e-4128-8565-d1679fb2e260.png\"}/\u003e\n  \u003cdiv style={{color: \"rgb(163 163 163)\", fontSize:\"12px\", margin: \"0 0 15px\"}}\u003e이미지 출처: [Blink의 Renderer Process](https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit#heading=h.v5plba74lfde)\u003c/div\u003e\n\n\n### 2. Render Tree 생성\n\n\u003caside\u003e\n  \u003cp className={\"text-lg\"}\u003e📖\u0026nbsp;\u0026nbsp;Render Tree\u003c/p\u003e\n  - 렌더링 엔진이 DOM Tree와 CSSOM Tree를 합쳐서 만든 트리\n  - 화면에 표시되어야 할 모든 노드의 컨텐츠, 스타일 정보를 포함하는 트리\n\u003c/aside\u003e\n\ndocument 객체부터 각 노드를 순회하면서 각각의 맞는 CSSOM를 찾아서 규칙을 적용하며 렌더와 관련된 요소들을 렌더 트리에 포함시킨다.\n\n이 때, `meta tag`나 `display: none` 속성을 가진 요소들은 렌더와 관계가 없기에 렌더 트리에 포함되지 않는다.\n\n\u003cimg style={{margin:\"20px 0 5px\"}} alt={\"Render_Tree_Construction_Layout_and_Paint\"} src={\"https://user-images.githubusercontent.com/56423604/269020715-b0948780-e34b-4b57-b809-8e78fd6c0c38.png\"}/\u003e\n  \u003cdiv style={{color: \"rgb(163 163 163)\", fontSize:\"12px\", margin: \"0 0 15px\"}}\u003e이미지 출처: [[Critical Rendering Path] Render-Tree Construction, Layout, and Paint](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko)\u003c/div\u003e\n\n### 3. Render Tree 배치: Layout(Reflow)\n\nRender Tree 가 생성되면 Layout(Reflow)이라는 과정을 거친다. viewport 내에서 요소들에 정확한 위치와 크기를 (모든 스타일 속성이) 계산하는 과정이다.\n\n이때 `%`, `em`과 같은 상대적인 단위를 사용했을 때는 viewport 에 맞춰서 픽셀단위로 변환된다.\n\n### 4. Render Tree 그리기: Paint(Repaint)\n렌더링 엔진이 각 요소들이 실제로 그려지는 과정이다.\n\n\n# UI가 업데이트 되는 3가지 상황\n\n위에는 브라우저가 페이지의 초기 출력을 위해 실행해야 하는 순서라면, UI가 사용자와의 상호작용 통해 업데이트 경우가 존재한다.\n과정이 1 \\\u003c 2\\\u003c 3 순으로 적기에 높은 숫자일수록 성능이 우수하다.\n\n## 1. Layout 이 다시 발생하는 경우\n\u003cspan style={{fontSize: \"18px\", fontWeight:\"700\"}}\u003e: JavaScript → Style → Layout → Paint → Composite\u003c/span\u003e\n\n* 주로 요소의 크기나 위치가 바뀔 때, 혹은 브라우저 창의 크기가 바뀌었을 때 다시 발생\n* 이 때, 레이아웃 수치를 다시 계산해서 재배치 해야 하기에 레이아웃 과정과 페인트, 레이어 합성 과정이 다시 발생한다.\n\n## 2. Paint 부터 다시 발생하는 경우\n\u003cspan style={{fontSize: \"18px\", fontWeight:\"700\"}}\u003e: JavaScript → Style → Paint → Composite\u003c/span\u003e\n\n* 주로 배경 이미지나 텍스트 색상, 그림자 등 레이아웃의 수치를 변화시키지 않는 스타일의 변경이 일어났을 경우 발생\n* 레이아웃이 변경되지 않기에 성능적으로 1번보다 더욱 우수\n\n## 3. 레이어의 합성(Composite)만 다시 발생하는 경우\n\u003cspan style={{fontSize: \"18px\", fontWeight:\"700\"}}\u003e: JavaScript → Style → Composite\u003c/span\u003e\n\n* Layout과 Paint를 수행하지 않고 레이어의 합성만 발생하기에 성능적으로 가장 우수한 케이스이다.\n* 레이어란 페인팅할 영역을 나누어 놓는 것을 의미한다. 크롬의 경우에는 Layout 과정 이후에 정해진 기준이나 필요에 의해 브라우저가 레이어를 생성한다.\n* 렌더 트리에 있는 노드 객체들은 생성된 레이어에 포함된다. 레이어들은 트리 형태 구성된다.\u003cbr/\u003e\n    → 렌더링 엔진이 각 레이어를 프린팅 과정에서 각각 그려 준 다음에 하나의 비트맵으로 합성하여 페이지를 완성한다.\n\n아래의 사이트에서 CSS 속성마다 렌더링 엔진별로 UI가 어떻게 업데이트 되는지 알 수 있다.\n\u003ca href={\"https://csstriggers.com/\"} target={\"_blank\"} style={{cursor:\"pointer\"}}\u003e\n  \u003cimg width={400} style={{margin:\"20px auto\"}} alt={\"css-Triggers-List-2\"} src={\"https://user-images.githubusercontent.com/56423604/269030495-c1f213be-82eb-423b-a80d-20858694b7de.png\"}/\u003e\n\u003c/a\u003e\n\n# 개발자 도구로 리렌더 과정 살펴 보기\n실습은 해당 사이트에서 진행되었습니다. : [Rendering Engine Practice](https://coyo-hm.github.io/rendering_engine_practice/)\n\n## align-items 를 변경하는 경우\n\n\u003cimg style={{margin:\"20px 0 5px\"}} alt={\"cssom-align-items\"} src={\"https://user-images.githubusercontent.com/56423604/269034349-fb2298eb-12cc-481b-b0c0-f40eaaf4577c.png\"}/\u003e\n  \u003cdiv style={{color: \"rgb(163 163 163)\", fontSize:\"12px\", margin: \"0 0 15px\"}}\u003e이미지 출처: [CSS Triggers List – What Kind of Changes You Can Make](https://csstriggers.com/)\u003c/div\u003e\n\n* Blink\n\nCSS Triggers 에 따르면, Blink 기준으로 Layout 부터 다시 발생(: JavaScript → Style → Layout → Paint → Composite)한다.\n\u003cimg style={{margin:\"20px 0\"}} alt=\"blink-align-items\" src=\"https://user-images.githubusercontent.com/56423604/269039092-99232f88-01cf-4cd6-ae7e-805200bb5c47.png\"/\u003e\n개발자 도구 performance 탭을 살펴보면 Recalculate → Layout → Pre Paint → Paint → Layerize → Commit 순서로 렌더링 되었음을 확인할 수 있다.\n\n## border-right-color 을 변경하는 경우\n\n\u003cimg style={{margin:\"20px 0 5px\"}} alt={\"cssom-border-right-color\"} src={\"https://user-images.githubusercontent.com/56423604/269040996-650204fc-3c75-4da8-b1d5-7ea6aa7ff5f0.png\"}/\u003e\n  \u003cdiv style={{color: \"rgb(163 163 163)\", fontSize:\"12px\", margin: \"0 0 15px\"}}\u003e이미지 출처: [CSS Triggers List – What Kind of Changes You Can Make](https://csstriggers.com/)\u003c/div\u003e\n\n* Blink\n\n    `border-right-color`를 바꾸는 경우에는 위의 설명에도 나와 있고 CSS Triggers 에서도 Blink 기준으로 Paint 부터 다시 발생(: JavaScript → Style → Paint → Composite)하는 것을 알 수 있다.\n\u003cimg style={{margin:\"20px 0\"}} alt=\"blink-border-right-color\" src=\"https://user-images.githubusercontent.com/56423604/269042941-cf22c84c-0d19-4655-af70-70ce9ec34b36.png\"/\u003e\n\n\n## background-color 을 변경하는 경우\n\n\u003cimg style={{margin:\"20px 0 5px\"}} alt={\"cssom-background-color\"} src={\"https://user-images.githubusercontent.com/56423604/269041943-6ed739dd-3d9d-4737-9aa1-390f1ff09a1c.png\"}/\u003e\n  \u003cdiv style={{color: \"rgb(163 163 163)\", fontSize:\"12px\", margin: \"0 0 15px\"}}\u003e이미지 출처: [CSS Triggers List – What Kind of Changes You Can Make](https://csstriggers.com/)\u003c/div\u003e\n\n* Blink\n\n    `background-color`를 바꾸는 경우에는 위의 설명에도 나와 있고 CSS Triggers 에서도 Blink 기준으로 Paint 부터 다시 발생(: JavaScript → Style → Paint → Composite)하는 것을 알 수 있다.\n\u003cimg style={{margin:\"20px 0\"}} alt=\"blink-border-right-color\" src=\"https://user-images.githubusercontent.com/56423604/269042941-cf22c84c-0d19-4655-af70-70ce9ec34b36.png\"/\u003e\n\n\n\n## opacity 를 변경하는 경우\n\n\u003cimg style={{margin:\"20px 0 5px\"}} alt={\"cssom-opacity\"} src={\"https://user-images.githubusercontent.com/56423604/269042111-bb3c95ca-2874-4677-81f1-26569fc269de.png\"}/\u003e\n  \u003cdiv style={{color: \"rgb(163 163 163)\", fontSize:\"12px\", margin: \"0 0 15px\"}}\u003e이미지 출처: [[CSS] opacity는 reflow가 발생 안 한다구요...? 정말??](https://blinders.tistory.com/93)\u003c/div\u003e\n\nCSS Triggers 에 따르면, Blink 기준으로 Paint 부터 다시 발생(: JavaScript → Style → Paint → Composite)한다.\n\n그런데 처음에 `opacity`를 기본값인 1에서 0으로 변하고 1로 변할때 layout 과정이 발생한 것을 발견할 수 있었다.\n\n\u003cimg style={{margin:\"20px 0\"}} alt=\"blink-opcity2\" src=\"https://user-images.githubusercontent.com/56423604/269047824-78cadf35-afc2-4743-b7c6-20c7a9807ecb.png\"/\u003e\n\n이에 대해 찾아보니 위에서 말했듯이 브라우저가 코드를 렌더링하기 위해서는 HTML를 파싱하여 DOM Tree를 구성하고 DOM Tree와 CSSOM Tree를 하나로 합쳐 Render Tree로 만들고, 그 Render Tree를 바탕으로 Layer(레이어)를 구성한다.\n\n이때 이 레이어가 실제 포토샵에서 쓰는 레이어와 비슷한 의미의 언어로 층을 의미하는데, 브라우저는 레이어를 쌓아가며 화면을 구성하여 우리에게 보여준다. 앞에 레이어에 가려진 것을 뿐 뒤에 레이어에도 엄연히 화면이 그려진 3차원이라고 볼 수 있다.\n이를 [`Stacking Context`](https://developer.mozilla.org/ko/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context)라고 하며 MDN에서는 `가상의 Z축을 사용한 HTML 요소의 3차원 개념화`이라고 한다.각각의 HTML 요소는 자신의 속성에 따른 우선순위를 사용해 3차원 공간을 차지한다.\n\n`Stacking Context`는 조건에 따라 `document` 어디에서나 다음 조건을 만족하는 element가 생성된다.\n\n* document의 root element. (`\u003chtml\u003e`)\n* position이 absolute 또는 relative이고, z-index가 auto가 아닌 요소.\n* position이 fixed 또는 sticky인 요소. (sticky는 모든 모바일 브라우저에서는 해당하지만 구형 데스크톱 브라우저에서는 해당하지 않음)\n* 플렉스(flexbox (en-US)) 컨테이너의 자식 중 z-index가 auto가 아닌 요소.\n* 그리드(grid (en-US)) 컨테이너의 자식 중 z-index가 auto가 아닌 요소.\n* opacity가 1보다 작은 요소. (불투명도 명세 참고)\n* mix-blend-mode가 normal이 아닌 요소.\n* 다음 속성 중 하나라도 none이 아닌 값을 가진 요소.\n  * transform\n  * filter\n  * perspective (en-US)\n  * clip-path\n  * mask / mask-image (en-US) / mask-border (en-US)\n* isolation이 isolate인 요소.\n* -webkit-overflow-scrolling이 touch인 요소.\n* will-change의 값으로, 초깃값이 아닐 때 새로운 쌓임 맥락을 생성하는 속성을 지정한 요소.\n* contain이 layout, paint, 또는 둘 중 하나를 포함하는 값(strict, content 등)인 요소.\n\n우리는 여기서 `* opacity가 1보다 작은 요소. (불투명도 명세 참고)` 요 부분에 주목할 필요가 있다.\n설정한 에니메이션에서는 기본값인 opacity 1에서 0으로 변화했다가 다시 1로 변화했기에 해당 요소가 별도의 레이어를 가졌다는 것을 알 수 있다.\n그래서 레이아웃 과정부터 요소들을 재계산하고 레이어를 생성하여 재배치해줄 과정이 필요한 것이다.\n\n그래서 처음부터 opacity 값을 1보다 작은 0.99로 주고 0으로 변한 후 다시 0.99로 돌아왔을 경우에는 다음과 같이 우리가 원했던 Paint 부터 시작되는 것을 볼 수 있었다.\n\n\u003cimg style={{margin:\"20px 0\"}} alt=\"blink-opcity1\" src=\"https://user-images.githubusercontent.com/56423604/269052188-a640204a-4c53-405f-aade-aefa052dede6.png\"/\u003e\n\n# 참조\n- [[10분 테코톡] ☕️ 체프의 브라우저 렌더링](https://www.youtube.com/watch?v=sJ14cWjrNis)\n- [브라우저의 렌더링 과정 \u0026 Render Tree와 DOM Tree의 차이점](https://hyojin96.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95-Render-Tree%EC%99%80-DOM-Tree%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90)\n- [[Critical Rendering Path] Render-Tree Construction, Layout, and Paint](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko)\n- [Constructing the Object Model](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko)\n- [Render-tree Construction, Layout, and Paint](https://web.dev/critical-rendering-path-render-tree-construction/?hl=ko)\n- [Blink의 Renderer Process](https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit#heading=h.v5plba74lfde)\n- [[CSS] opacity는 reflow가 발생 안 한다구요...? 정말??](https://blinders.tistory.com/93)\n- [[MDN] Stacking Context](https://developer.mozilla.org/ko/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context)","fields":{"slug":"browser-rendering"},"path":"browser-rendering.mdx"},"mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h1: \"h1\",\n    a: \"a\",\n    span: \"span\",\n    blockquote: \"blockquote\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    h3: \"h3\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"브라우저 렌더링에 대해 탐구해보자 그러기엔 우선 웹 브라우저 구조를 간단하게 살펴보자.\"\n    }), \"\\n\", _jsxs(_components.h1, {\n      id: \"웹-브라우저-구조\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#웹-브라우저-구조\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"웹 브라우저 구조\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"웹 브라우저\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"코드(CSS, HTML, JavaScript 등등)를 가지고 웹 페이지를 그려주는 역할을 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"https://user-images.githubusercontent.com/56423604/268966576-73d71f41-92eb-4042-8dbf-78043990c7a2.png\",\n      alt: \"web-browser-structure\",\n      style: {\n        margin: \"20px 0\"\n      }\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"User Interface\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"주소표시줄, 이전/다음/새로고침 버튼 등 웹페이지를 제외하고 사용자와 상호작용하는 사용자 인터페이스이다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Browser Engine\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"유저인터페이스와 렌더링 엔진을 연결하는 브라우저 엔진\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Rendering Engine\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"HTML과 CSS를 파싱하여 요청하는 웹 페이지를 표시하는 렌더링 엔진\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Networking\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"각종 네트워크 요청을 수행하는 네트워킹 파트\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"JavaScript Interpreter\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"자바스크립트 코드를 실행하는 인터프리터 (크롬의 경우 V8을 사용하는 엔진)\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"UI Backend\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"체크박스나 버튼과 같은 기본적인 위젯을 그려주는 UI Backend 파트\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Data Science\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"localStorage나 Cookie와 같이 보조 기억 장치에 데이터를 저장하는 파트\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h1, {\n      id: \"rendering-engine\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#rendering-engine\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Rendering Engine\"]\n    }), \"\\n\", _jsxs(\"aside\", {\n      children: [_jsx(\"p\", {\n        className: \"text\",\n        children: \"💡  웹 브라우저마다 렌더링 엔진이 다르다\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Chrome은 Blink, 신형 Edge\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Safari는 Webkit\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Firefox는 Gecko\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Trident은 IE\"\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"rendering-engine의-역할\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#rendering-engine의-역할\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Rendering Engine의 역할\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"✔️ HTML, CSS, JS, 이미지 등 웹페이지에 포함된 모든 요소들을 화면에 보여준다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"✔️ 업데이트\", _jsx(\"span\", {\n        style: {\n          color: \"rgb(163 163 163)\"\n        },\n        children: \"(사용자 동작으로 인해서 입력이 발생한다던가, 스크롤이 생겼다던가 등의 업데이트)\"\n      }), \"가 필요할 때, 효율적으로 렌더링을 할 수 있도록 자료 구조를 생성한다.\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"rendering-engine의-동작-과정-critical-rendering-pathcrp\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#rendering-engine의-동작-과정-critical-rendering-pathcrp\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Rendering Engine의 동작 과정: Critical Rendering Path(CRP)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"브라우저가 페이지의 초기 출력을 위해 실행해야 하는 순서\"\n    }), \"\\n\", _jsx(\"img\", {\n      width: \"1685\",\n      style: {\n        margin: \"20px 0\"\n      },\n      alt: \"rendering-engine\",\n      src: \"https://github.com/COYO-HM/COYO-HM.github.io/assets/56423604/e7ec1ccb-2414-4f31-851a-a8a3c7b5a37f\"\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"20px 0 5px\"\n      },\n      alt: \"renderer-process\",\n      src: \"https://user-images.githubusercontent.com/56423604/268993997-6460af95-26ae-4798-a1da-d9f008ebabc6.png\"\n    }), \"\\n\", _jsxs(\"div\", {\n      style: {\n        color: \"rgb(163 163 163)\",\n        fontSize: \"12px\",\n        margin: \"0 0 15px\"\n      },\n      children: [\"이미지 출처: \", _jsx(_components.a, {\n        href: \"https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit#heading=h.v5plba74lfde\",\n        children: \"Blink의 Renderer Process\"\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"1-dom-tree와-cssom-tree의-생성\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#1-dom-tree와-cssom-tree의-생성\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"1. DOM Tree와 CSSOM Tree의 생성\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저 브라우저에서 사용자가 요청한 웹페이지에 문서를 불러오고 HTML tag들을 토큰화(Tokenizer)한다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"토큰화한 후에 브라우저가 렉싱(Lexing) 과정을 통해 토큰을 해당 속성과 규칙을 정의하는 노드 객체로 변환한다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"파싱(Parsing) 과정을 통해 각 노드가 서로 연관성을 가질 수 있도록 트리를 생성한다 ⇒ DOM Tree 생성\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"HTML 문서에 잇는 모든 것들은 DOM을 구성한다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"최상위에는 \", _jsx(_components.code, {\n        children: \"document\"\n      }), \" 객체가 들어가고 태그는 element node(html)가 되고 태그의 요소는 attribute node, text node가 되어 트리 구조로 생성한다(이외에도 주석은 comment node가 되어 생성된다).\"]\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"20px 0 5px\"\n      },\n      alt: \"Constructing-the-Object-Model\",\n      src: \"https://user-images.githubusercontent.com/56423604/269012635-a403bf07-45b5-43ef-9c4a-996671ed7693.png\"\n    }), \"\\n\", _jsxs(\"div\", {\n      style: {\n        color: \"rgb(163 163 163)\",\n        fontSize: \"12px\",\n        margin: \"0 0 15px\"\n      },\n      children: [\"이미지 출처: \", _jsx(_components.a, {\n        href: \"https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit#heading=h.v5plba74lfde\",\n        children: \"Blink의 Renderer Process\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"HTML을 DOM 트리로 만드는 과정과 비슷하게 CSS의 경우 CSSOM Tree가 만들어진다. \", _jsx(\"br\", {}), \"DOM 생성하는 동안 CSS 스타일시트 링크 태그를 접하고 리소스에 대해 요청한다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"CSS도 브라우저가 이해하고 처리할 수 있도록 CSSOM Tree로 변환한다.\", _jsx(\"br\", {}), \"CSSOM은 DOM이 어떻게 화면에 표시될 지를 알려주는 역할을 한다.\"]\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"20px 0\"\n      },\n      alt: \"CSSOM\",\n      src: \"https://user-images.githubusercontent.com/56423604/269015530-9fd4cab4-6050-4ed4-a5b3-90c6cdc45d41.png\"\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"0 0 5px\"\n      },\n      alt: \"CSSOM\",\n      src: \"https://user-images.githubusercontent.com/56423604/269018447-1195e2fe-e57e-4128-8565-d1679fb2e260.png\"\n    }), \"\\n\", _jsxs(\"div\", {\n      style: {\n        color: \"rgb(163 163 163)\",\n        fontSize: \"12px\",\n        margin: \"0 0 15px\"\n      },\n      children: [\"이미지 출처: \", _jsx(_components.a, {\n        href: \"https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit#heading=h.v5plba74lfde\",\n        children: \"Blink의 Renderer Process\"\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"2-render-tree-생성\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#2-render-tree-생성\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"2. Render Tree 생성\"]\n    }), \"\\n\", _jsxs(\"aside\", {\n      children: [_jsx(\"p\", {\n        className: \"text-lg\",\n        children: \"📖  Render Tree\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"렌더링 엔진이 DOM Tree와 CSSOM Tree를 합쳐서 만든 트리\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"화면에 표시되어야 할 모든 노드의 컨텐츠, 스타일 정보를 포함하는 트리\"\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"document 객체부터 각 노드를 순회하면서 각각의 맞는 CSSOM를 찾아서 규칙을 적용하며 렌더와 관련된 요소들을 렌더 트리에 포함시킨다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이 때, \", _jsx(_components.code, {\n        children: \"meta tag\"\n      }), \"나 \", _jsx(_components.code, {\n        children: \"display: none\"\n      }), \" 속성을 가진 요소들은 렌더와 관계가 없기에 렌더 트리에 포함되지 않는다.\"]\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"20px 0 5px\"\n      },\n      alt: \"Render_Tree_Construction_Layout_and_Paint\",\n      src: \"https://user-images.githubusercontent.com/56423604/269020715-b0948780-e34b-4b57-b809-8e78fd6c0c38.png\"\n    }), \"\\n\", _jsxs(\"div\", {\n      style: {\n        color: \"rgb(163 163 163)\",\n        fontSize: \"12px\",\n        margin: \"0 0 15px\"\n      },\n      children: [\"이미지 출처: \", _jsx(_components.a, {\n        href: \"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko\",\n        children: \"[Critical Rendering Path] Render-Tree Construction, Layout, and Paint\"\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"3-render-tree-배치-layoutreflow\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#3-render-tree-배치-layoutreflow\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"3. Render Tree 배치: Layout(Reflow)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Render Tree 가 생성되면 Layout(Reflow)이라는 과정을 거친다. viewport 내에서 요소들에 정확한 위치와 크기를 (모든 스타일 속성이) 계산하는 과정이다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이때 \", _jsx(_components.code, {\n        children: \"%\"\n      }), \", \", _jsx(_components.code, {\n        children: \"em\"\n      }), \"과 같은 상대적인 단위를 사용했을 때는 viewport 에 맞춰서 픽셀단위로 변환된다.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"4-render-tree-그리기-paintrepaint\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#4-render-tree-그리기-paintrepaint\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"4. Render Tree 그리기: Paint(Repaint)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"렌더링 엔진이 각 요소들이 실제로 그려지는 과정이다.\"\n    }), \"\\n\", _jsxs(_components.h1, {\n      id: \"ui가-업데이트-되는-3가지-상황\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ui가-업데이트-되는-3가지-상황\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"UI가 업데이트 되는 3가지 상황\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위에는 브라우저가 페이지의 초기 출력을 위해 실행해야 하는 순서라면, UI가 사용자와의 상호작용 통해 업데이트 경우가 존재한다.\\n과정이 1 \u003c 2\u003c 3 순으로 적기에 높은 숫자일수록 성능이 우수하다.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"1-layout-이-다시-발생하는-경우\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#1-layout-이-다시-발생하는-경우\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"1. Layout 이 다시 발생하는 경우\"]\n    }), \"\\n\", _jsx(\"span\", {\n      style: {\n        fontSize: \"18px\",\n        fontWeight: \"700\"\n      },\n      children: \": JavaScript → Style → Layout → Paint → Composite\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"주로 요소의 크기나 위치가 바뀔 때, 혹은 브라우저 창의 크기가 바뀌었을 때 다시 발생\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이 때, 레이아웃 수치를 다시 계산해서 재배치 해야 하기에 레이아웃 과정과 페인트, 레이어 합성 과정이 다시 발생한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"2-paint-부터-다시-발생하는-경우\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#2-paint-부터-다시-발생하는-경우\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"2. Paint 부터 다시 발생하는 경우\"]\n    }), \"\\n\", _jsx(\"span\", {\n      style: {\n        fontSize: \"18px\",\n        fontWeight: \"700\"\n      },\n      children: \": JavaScript → Style → Paint → Composite\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"주로 배경 이미지나 텍스트 색상, 그림자 등 레이아웃의 수치를 변화시키지 않는 스타일의 변경이 일어났을 경우 발생\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"레이아웃이 변경되지 않기에 성능적으로 1번보다 더욱 우수\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"3-레이어의-합성composite만-다시-발생하는-경우\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#3-레이어의-합성composite만-다시-발생하는-경우\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"3. 레이어의 합성(Composite)만 다시 발생하는 경우\"]\n    }), \"\\n\", _jsx(\"span\", {\n      style: {\n        fontSize: \"18px\",\n        fontWeight: \"700\"\n      },\n      children: \": JavaScript → Style → Composite\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Layout과 Paint를 수행하지 않고 레이어의 합성만 발생하기에 성능적으로 가장 우수한 케이스이다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"레이어란 페인팅할 영역을 나누어 놓는 것을 의미한다. 크롬의 경우에는 Layout 과정 이후에 정해진 기준이나 필요에 의해 브라우저가 레이어를 생성한다.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"렌더 트리에 있는 노드 객체들은 생성된 레이어에 포함된다. 레이어들은 트리 형태 구성된다.\", _jsx(\"br\", {}), \"\\n→ 렌더링 엔진이 각 레이어를 프린팅 과정에서 각각 그려 준 다음에 하나의 비트맵으로 합성하여 페이지를 완성한다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래의 사이트에서 CSS 속성마다 렌더링 엔진별로 UI가 어떻게 업데이트 되는지 알 수 있다.\"\n    }), \"\\n\", _jsx(\"a\", {\n      href: \"https://csstriggers.com/\",\n      target: \"_blank\",\n      style: {\n        cursor: \"pointer\"\n      },\n      children: _jsx(\"img\", {\n        width: 400,\n        style: {\n          margin: \"20px auto\"\n        },\n        alt: \"css-Triggers-List-2\",\n        src: \"https://user-images.githubusercontent.com/56423604/269030495-c1f213be-82eb-423b-a80d-20858694b7de.png\"\n      })\n    }), \"\\n\", _jsxs(_components.h1, {\n      id: \"개발자-도구로-리렌더-과정-살펴-보기\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#개발자-도구로-리렌더-과정-살펴-보기\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"개발자 도구로 리렌더 과정 살펴 보기\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"실습은 해당 사이트에서 진행되었습니다. : \", _jsx(_components.a, {\n        href: \"https://coyo-hm.github.io/rendering_engine_practice/\",\n        children: \"Rendering Engine Practice\"\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"align-items-를-변경하는-경우\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#align-items-를-변경하는-경우\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"align-items 를 변경하는 경우\"]\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"20px 0 5px\"\n      },\n      alt: \"cssom-align-items\",\n      src: \"https://user-images.githubusercontent.com/56423604/269034349-fb2298eb-12cc-481b-b0c0-f40eaaf4577c.png\"\n    }), \"\\n\", _jsxs(\"div\", {\n      style: {\n        color: \"rgb(163 163 163)\",\n        fontSize: \"12px\",\n        margin: \"0 0 15px\"\n      },\n      children: [\"이미지 출처: \", _jsx(_components.a, {\n        href: \"https://csstriggers.com/\",\n        children: \"CSS Triggers List – What Kind of Changes You Can Make\"\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Blink\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"CSS Triggers 에 따르면, Blink 기준으로 Layout 부터 다시 발생(: JavaScript → Style → Layout → Paint → Composite)한다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"20px 0\"\n      },\n      alt: \"blink-align-items\",\n      src: \"https://user-images.githubusercontent.com/56423604/269039092-99232f88-01cf-4cd6-ae7e-805200bb5c47.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"개발자 도구 performance 탭을 살펴보면 Recalculate → Layout → Pre Paint → Paint → Layerize → Commit 순서로 렌더링 되었음을 확인할 수 있다.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"border-right-color-을-변경하는-경우\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#border-right-color-을-변경하는-경우\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"border-right-color 을 변경하는 경우\"]\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"20px 0 5px\"\n      },\n      alt: \"cssom-border-right-color\",\n      src: \"https://user-images.githubusercontent.com/56423604/269040996-650204fc-3c75-4da8-b1d5-7ea6aa7ff5f0.png\"\n    }), \"\\n\", _jsxs(\"div\", {\n      style: {\n        color: \"rgb(163 163 163)\",\n        fontSize: \"12px\",\n        margin: \"0 0 15px\"\n      },\n      children: [\"이미지 출처: \", _jsx(_components.a, {\n        href: \"https://csstriggers.com/\",\n        children: \"CSS Triggers List – What Kind of Changes You Can Make\"\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Blink\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.code, {\n            children: \"border-right-color\"\n          }), \"를 바꾸는 경우에는 위의 설명에도 나와 있고 CSS Triggers 에서도 Blink 기준으로 Paint 부터 다시 발생(: JavaScript → Style → Paint → Composite)하는 것을 알 수 있다.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"20px 0\"\n      },\n      alt: \"blink-border-right-color\",\n      src: \"https://user-images.githubusercontent.com/56423604/269042941-cf22c84c-0d19-4655-af70-70ce9ec34b36.png\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"background-color-을-변경하는-경우\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#background-color-을-변경하는-경우\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"background-color 을 변경하는 경우\"]\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"20px 0 5px\"\n      },\n      alt: \"cssom-background-color\",\n      src: \"https://user-images.githubusercontent.com/56423604/269041943-6ed739dd-3d9d-4737-9aa1-390f1ff09a1c.png\"\n    }), \"\\n\", _jsxs(\"div\", {\n      style: {\n        color: \"rgb(163 163 163)\",\n        fontSize: \"12px\",\n        margin: \"0 0 15px\"\n      },\n      children: [\"이미지 출처: \", _jsx(_components.a, {\n        href: \"https://csstriggers.com/\",\n        children: \"CSS Triggers List – What Kind of Changes You Can Make\"\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Blink\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.code, {\n            children: \"background-color\"\n          }), \"를 바꾸는 경우에는 위의 설명에도 나와 있고 CSS Triggers 에서도 Blink 기준으로 Paint 부터 다시 발생(: JavaScript → Style → Paint → Composite)하는 것을 알 수 있다.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"20px 0\"\n      },\n      alt: \"blink-border-right-color\",\n      src: \"https://user-images.githubusercontent.com/56423604/269042941-cf22c84c-0d19-4655-af70-70ce9ec34b36.png\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"opacity-를-변경하는-경우\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#opacity-를-변경하는-경우\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"opacity 를 변경하는 경우\"]\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"20px 0 5px\"\n      },\n      alt: \"cssom-opacity\",\n      src: \"https://user-images.githubusercontent.com/56423604/269042111-bb3c95ca-2874-4677-81f1-26569fc269de.png\"\n    }), \"\\n\", _jsxs(\"div\", {\n      style: {\n        color: \"rgb(163 163 163)\",\n        fontSize: \"12px\",\n        margin: \"0 0 15px\"\n      },\n      children: [\"이미지 출처: \", _jsx(_components.a, {\n        href: \"https://blinders.tistory.com/93\",\n        children: \"[CSS] opacity는 reflow가 발생 안 한다구요...? 정말??\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"CSS Triggers 에 따르면, Blink 기준으로 Paint 부터 다시 발생(: JavaScript → Style → Paint → Composite)한다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"그런데 처음에 \", _jsx(_components.code, {\n        children: \"opacity\"\n      }), \"를 기본값인 1에서 0으로 변하고 1로 변할때 layout 과정이 발생한 것을 발견할 수 있었다.\"]\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"20px 0\"\n      },\n      alt: \"blink-opcity2\",\n      src: \"https://user-images.githubusercontent.com/56423604/269047824-78cadf35-afc2-4743-b7c6-20c7a9807ecb.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이에 대해 찾아보니 위에서 말했듯이 브라우저가 코드를 렌더링하기 위해서는 HTML를 파싱하여 DOM Tree를 구성하고 DOM Tree와 CSSOM Tree를 하나로 합쳐 Render Tree로 만들고, 그 Render Tree를 바탕으로 Layer(레이어)를 구성한다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이때 이 레이어가 실제 포토샵에서 쓰는 레이어와 비슷한 의미의 언어로 층을 의미하는데, 브라우저는 레이어를 쌓아가며 화면을 구성하여 우리에게 보여준다. 앞에 레이어에 가려진 것을 뿐 뒤에 레이어에도 엄연히 화면이 그려진 3차원이라고 볼 수 있다.\\n이를 \", _jsx(_components.a, {\n        href: \"https://developer.mozilla.org/ko/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context\",\n        children: _jsx(_components.code, {\n          children: \"Stacking Context\"\n        })\n      }), \"라고 하며 MDN에서는 \", _jsx(_components.code, {\n        children: \"가상의 Z축을 사용한 HTML 요소의 3차원 개념화\"\n      }), \"이라고 한다.각각의 HTML 요소는 자신의 속성에 따른 우선순위를 사용해 3차원 공간을 차지한다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Stacking Context\"\n      }), \"는 조건에 따라 \", _jsx(_components.code, {\n        children: \"document\"\n      }), \" 어디에서나 다음 조건을 만족하는 element가 생성된다.\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"document의 root element. (\", _jsx(_components.code, {\n          children: \"\u003chtml\u003e\"\n        }), \")\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"position이 absolute 또는 relative이고, z-index가 auto가 아닌 요소.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"position이 fixed 또는 sticky인 요소. (sticky는 모든 모바일 브라우저에서는 해당하지만 구형 데스크톱 브라우저에서는 해당하지 않음)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"플렉스(flexbox (en-US)) 컨테이너의 자식 중 z-index가 auto가 아닌 요소.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"그리드(grid (en-US)) 컨테이너의 자식 중 z-index가 auto가 아닌 요소.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"opacity가 1보다 작은 요소. (불투명도 명세 참고)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"mix-blend-mode가 normal이 아닌 요소.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"다음 속성 중 하나라도 none이 아닌 값을 가진 요소.\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"transform\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"filter\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"perspective (en-US)\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"clip-path\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"mask / mask-image (en-US) / mask-border (en-US)\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"isolation이 isolate인 요소.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"-webkit-overflow-scrolling이 touch인 요소.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"will-change의 값으로, 초깃값이 아닐 때 새로운 쌓임 맥락을 생성하는 속성을 지정한 요소.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"contain이 layout, paint, 또는 둘 중 하나를 포함하는 값(strict, content 등)인 요소.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"우리는 여기서 \", _jsx(_components.code, {\n        children: \"* opacity가 1보다 작은 요소. (불투명도 명세 참고)\"\n      }), \" 요 부분에 주목할 필요가 있다.\\n설정한 에니메이션에서는 기본값인 opacity 1에서 0으로 변화했다가 다시 1로 변화했기에 해당 요소가 별도의 레이어를 가졌다는 것을 알 수 있다.\\n그래서 레이아웃 과정부터 요소들을 재계산하고 레이어를 생성하여 재배치해줄 과정이 필요한 것이다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서 처음부터 opacity 값을 1보다 작은 0.99로 주고 0으로 변한 후 다시 0.99로 돌아왔을 경우에는 다음과 같이 우리가 원했던 Paint 부터 시작되는 것을 볼 수 있었다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      style: {\n        margin: \"20px 0\"\n      },\n      alt: \"blink-opcity1\",\n      src: \"https://user-images.githubusercontent.com/56423604/269052188-a640204a-4c53-405f-aade-aefa052dede6.png\"\n    }), \"\\n\", _jsxs(_components.h1, {\n      id: \"참조\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#참조\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"참조\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.youtube.com/watch?v=sJ14cWjrNis\",\n          children: \"[10분 테코톡] ☕️ 체프의 브라우저 렌더링\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://hyojin96.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95-Render-Tree%EC%99%80-DOM-Tree%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\",\n          children: \"브라우저의 렌더링 과정 \u0026 Render Tree와 DOM Tree의 차이점\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko\",\n          children: \"[Critical Rendering Path] Render-Tree Construction, Layout, and Paint\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko\",\n          children: \"Constructing the Object Model\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://web.dev/critical-rendering-path-render-tree-construction/?hl=ko\",\n          children: \"Render-tree Construction, Layout, and Paint\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit#heading=h.v5plba74lfde\",\n          children: \"Blink의 Renderer Process\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://blinders.tistory.com/93\",\n          children: \"[CSS] opacity는 reflow가 발생 안 한다구요...? 정말??\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://developer.mozilla.org/ko/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context\",\n          children: \"[MDN] Stacking Context\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[...slugs]","query":{"slugs":["browser-rendering"]},"buildId":"rFuoPSN9d4mpMmZN1yJqz","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>