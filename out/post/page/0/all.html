<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'G-EP9WH2T6FN', {
                page_path: window.location.pathname,
              });
            </script><meta name="next-head-count" content="3"/><link rel="canonical" href="https://coyo-hm.github.io/"/><link rel="icon" href="/favicons/favicon.ico"/><link rel="apple-touch-icon" sizes="76x76" href="/favicons/logo_76x76.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/logo_32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/logo_16x16.png"/><meta name="google-site-verification" content="HzJb0HTR2Qal7mndqRpQ6uBSJbCRXpZPnh7_Cn1oOgA"/><link rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/ff23e177763038dd.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ff23e177763038dd.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-91cbd5428e348355.js" defer=""></script><script src="/_next/static/chunks/pages/_app-7991a700aa65a103.js" defer=""></script><script src="/_next/static/chunks/95b64a6e-5c1c80ce1af5e491.js" defer=""></script><script src="/_next/static/chunks/130-48003d82f6f0c6cc.js" defer=""></script><script src="/_next/static/chunks/23-c30fcbf88acbcf47.js" defer=""></script><script src="/_next/static/chunks/pages/post/page/%5Bpage%5D/%5Btag%5D-2cef99ddc23829f3.js" defer=""></script><script src="/_next/static/d4lrTSL5DgHi3vKwnjH5I/_buildManifest.js" defer=""></script><script src="/_next/static/d4lrTSL5DgHi3vKwnjH5I/_ssgManifest.js" defer=""></script></head><body><div id="__next"></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"frontMatter":{"date":"2024-09-03T00:00:00","title":"동기와 비동기, 블록킹과 논블록킹 개념 정리","tags":["network","computer_science"],"description":"동기(Synchronous)와 비동기(Asynchronous), 블록킹(Blocking)과 논블록킹(Non-Blocking)에 대해 알아보기","thumbnail":"https://github.com/user-attachments/assets/2f87c239-464d-4974-9d9e-0ad75168fc14","published":true,"path":"sync-async.mdx","key":"sync-async","blurThumbnail":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAFCAYAAAB8ZH1oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAz0lEQVR4nGPQ1tb+bWNu9lddVe2vuJjkX3V1jb/KSsp/1ZVV/2pra/8xMDD4r62t/ZpBW1v7b05Y0P+1s/v+b941/7++meH/W6c3/f//8/p/SUmZfxYW5v/V1dXfMqirq/8NDAz8X11V+X/KtJ7/8Ylx/1ta6/7PnD3xf1RUzL/AwACIQhUVlT/x8fH/QkJD/7m6uv9zdXX9FxgY9M/O1v5ffHz83+Tk5P8KCgpvGCwsLEBu+c/Pzw/HIiIi/wWEBP5zcnL+MzEx+W9iYvIWAP1rWgJeFKZGAAAAAElFTkSuQmCC"},"body":"# 동기(Synchronous)와 비동기(Asynchronous)\n: 작업(프로세스)를 처리하는 방식, 작업 완료 여부에 초점\n\n| \u003cimg width=\"500\" alt=\"image\" src=\"https://github.com/user-attachments/assets/30ccd6f4-0f16-4aff-af19-e1c6ae73b203\"/\u003e | \u003cimg width=\"500\" alt=\"image\" src=\"https://github.com/user-attachments/assets/858dd7cc-d9be-41ec-a669-935c49d89de9\"/\u003e |\n| --- | --- |\n| * 요청(request)을 하면 요청한 자리에서 결과가 주어진다.\u003cbr/\u003e* 서버에서 요청(request)을 보냈을 때 응답(response)이 돌아와야 다음 작업을 진행할 수 있다.\u003cbr/\u003e =\u003e \u003cspan className=\"yellow\"\u003e요청(request)와 응답(reponse)의 순서가 보장된다.\u003c/span\u003e| * 요청(request)한 결과는 동시에 일어나지 않는다.\u003cbr/\u003e* 요청(request)을 보냈을 때 응답(reponse)과 상관없이 다음 동작을 수행할 수 있다.\u003cbr/\u003e=\u003e \u003cspan className=\"yellow\"\u003e요청(request)와 응답(reponse)의 순서가 보장되지 않는다.\u003c/span\u003e|\n| 순차적 진행 보장 O | 순차적 진행 보장 X |\n| 진행 중인 작업이 완료될 때까지 다른 작업 진행 X | 진행 중인 작업이 완료되지 않더라도 다른 작업 진행 O \u003cbr/\u003e=\u003e 느린 작업이 발생하더라도 다른 작업을 진행하기에 전반적인 시스템 성능 향상에 도움을 줄 수 있음 |\n\n# 블록킹(Blocking)과 논블록킹(Non-Blocking)\n: 프로세스 유휴 상태, 다른 요청의 작업을 처리하기 위해 현재 작업 여부(차단/대기)에 초점\n\n| 블록킹(Blocking) | 논블록킹(Non-Blocking) |\n| --- | --- |\n| \u003cimg width=\"500\" alt=\"image\" src=\"https://github.com/user-attachments/assets/534407bf-a9f4-4f0f-a885-9156a9418d78\"/\u003e | \u003cimg width=\"500\" alt=\"image\" src=\"https://github.com/user-attachments/assets/024083e1-c2fc-4e23-8414-8b1223e65071\"/\u003e |\n| 다른 작업이 다 수행될 때까지 현재 작업 차단 | 다른 작업과 현재 작업이 동시에 진행(현재 작업을 막지 않음 = non-blocking) |\n\n# 동기(Synchronous)/비동기(Asynchronous) + 블록킹(Blocking)/논블록킹(Non-Blocking)\n\u003cbr/\u003e\n\n| | 블록킹(Blocking)\u003cbr/\u003e\u003cspan className={\"font-normal\"}\u003e: 호출된 대상이 제어권을 가짐\u003c/span\u003e | 논블록킹(Non-Blocking)\u003cbr/\u003e\u003cspan className={\"font-normal\"}\u003e: 호출한 대상이 제어권을 가짐\u003c/span\u003e |\n| --- | --- | --- |\n|**동기(Synchronous)**\u003cbr/\u003e: 호출한 함수가 작업 완료 여부를 확인| \u003cimg width=\"360\" alt=\"image\" src=\"https://github.com/user-attachments/assets/60be6096-a2ee-4a6b-a080-b1cce0ac63fd\"/\u003e\u003cbr/\u003e* 코드 순차 진행\u003cbr/\u003e* 작업이 간단하거나 양이 적은 경우에 사용된다.\u003cbr/\u003e* 작업량이 많거나 복잡한 경우에는 시간이 오래 걸리기 때문에 비효율적이다. | \u003cimg width=\"360\" alt=\"image\" src=\"https://github.com/user-attachments/assets/aa1f156b-faca-429c-926e-a98f0fc752c5\"/\u003e\u003cbr/\u003e* 자신의 작업을 진행하고 있지만 다른 작업과의 동기를 위해서 계속해서 다른 작업의 완료 여부를 조회한다. |\n|**비동기(Asynchronous)**\u003cbr/\u003e: Callback 함수가 작업 완료 여부를 확인| \u003cimg width=\"360\" alt=\"image\" src=\"https://github.com/user-attachments/assets/aa808961-5b90-4c22-8b5b-2594b9a00afa\"/\u003e\u003cbr/\u003e* 블로킹으로 인해 결국 다른 작업이 끝날 때까지 기다려야 하기에 동기 + 블로킹 작업과 동일한 결과가 나온다. | \u003cimg width=\"360\" alt=\"image\" src=\"https://github.com/user-attachments/assets/c567926e-d881-4b97-9855-20020c89ece0\"/\u003e\u003cbr/\u003e* 자원이 충분하다면 가장 효율이 좋은 조합이다.\u003cbr/\u003e* 순차가 보장되지 않기에 동기가 필요하지 않고 작업이 대규모이고 시간이 오래 걸리는 경우에 사용하면 좋다. |\n\n# 참조\n* [완벽히 이해하는 동기/비동기 \u0026 블로킹/논블로킹](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC)\n* [동기/비동기와 블로킹/논블로킹](https://deveric.tistory.com/99)","fields":{"slug":"sync-async"},"path":"sync-async.mdx"},{"frontMatter":{"date":"2024-08-24T00:00:00","title":"assignInlineVars 사용시에 nextjs warning 해결하기","tags":["nextjs","vanilla_extract"],"series":["trouble_shooting"],"description":"nextjs 환경에서 vanilla-extract assignInlineVars 사용시에 `Warning: Only plain objects can be passed to Client Components from Server Components. Classes or other objects with methods are not supported.` warning 해결하기","thumbnail":"https://github.com/user-attachments/assets/233542e4-436d-4a51-a052-a16605deef28","published":true,"path":"assignInlineVars-to-client-from-server.mdx","key":"assignInlineVars-to-client-from-server","blurThumbnail":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAFCAYAAAB8ZH1oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAqElEQVR4nD2NPQ6CQBCFVxMLO7SwkmAl3IEWY+E/R7TxAGYlXoGGhKzhBhSoNWSZnWd2SXzVlzdf5gkAvdbadG1riNk09cs0tTIAjNYdYchb2MISUe+a5y3C/bp2rHXHw42+TjyezvC8OZa+j9lUYOEJx6PxhC9pal0n0iPLOI5jTpKEN9sd7w8ph2HEQbAyUkorftxHIoJSCkVRoKoq5HkOK5Rl+Z/+Ab3umpxUBd+4AAAAAElFTkSuQmCC"},"body":"# ⚠️ 문제\n\n\n  \u003cimg src={\"https://github.com/user-attachments/assets/b94f9789-11fb-493f-9afb-6fba94957f17\"} alt={\"warning-plain-objects-to-client-from-server\"}/\u003e\n\n  우선 `*Warning: Only plain objects can be passed to Client Components from Server Components.*` 오류는 서버 컴포넌트에서 클라이언트 컴포넌트에 `props`로 내려줄때 `serialize` 해주지 않아 생기는 오류이다.\n\n    \u003caside\u003e\n    💡 `serialize`\n\n    간단히 말하면 객체를 다른 환경에서도 사용할 수 있게 바꾸는 것, 파싱할 수 있는 데이터(e.g. `json`)의 형태로 만드는 것\n\n    \u003c/aside\u003e\n\n# 🔧 해결\n\n  vanilla-extract의 `assignInlineVars` 반환 값을 `json`으로 파싱해주면 해당 `warning`은 해결된다.\n\n## before\n\n  ```tsx\n  \u003cdiv className={styles.groupIconStyle} style={assignInlineVars({ [styles.setGroupColor]: color})}\u003e\n  ```\n\n## after\n\n  ```tsx\n  \u003cdiv className={styles.groupIconStyle} style={JSON.parse(JSON.stringify(assignInlineVars({ [styles.setGroupColor]: color })))}\u003e\n  ```\n\n# 참조\n\n  - https://github.com/vanilla-extract-css/vanilla-extract/issues/1246","fields":{"slug":"assignInlineVars-to-client-from-server"},"path":"assignInlineVars-to-client-from-server.mdx"},{"frontMatter":{"date":"2024-08-06T00:00:00","title":"nextjs-intl: Next.js 환경에서 다국어 지원하기","tags":["nextjs","next_intl"],"series":[],"description":"Next.js 환경에서 next-intl로 pathname에 따라 다국어 지원하기","thumbnail":"https://github.com/user-attachments/assets/e620e3a5-a456-4234-a6b7-a0a8a81a2256","published":true,"path":"nextjs-intl.mdx","key":"nextjs-intl","blurThumbnail":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAFCAYAAAB8ZH1oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAi0lEQVR4nGP4////7//////Fhr9///7nPwS8ZoAK/n/x+s3/3afO/r93797/E8eP/z+wfz+I/Q8k9/3797dghe/evf0/e/7i/9r2bv95+Pj/a+sb/bd2dPnfN3UmisI/a9eu+6egqPxPVFT8HxMz27/Zi5f/23Pq3L/++Uv/fv35E6T2DdxqHABuIgCXNaqfMqUQ5gAAAABJRU5ErkJggg=="},"body":"`nextjs`로 새로운 프로젝트를 진행하는 중에 다국어를 미리 지원해두면 편할 것 같아서 다국어 지원 라이브러리를 적용하면서 그 방법을 정리해두려고 합니다.\n\n`nextjs`로 다국어 지원은 처음이라 다양한 라이브러리를 찾아보았는데 그 중에서도 `app router`를 지원하는 라이브러리는 `next-intl`이 가장 깔끔해서 해당 라이브러리를 선택하였습니다.\n\nnext-intl에서 제공하는 [example](https://github.com/amannn/next-intl/tree/main/examples/example-app-router)과 [공식 docs](https://next-intl-docs.vercel.app/docs/getting-started/app-router)를 따라 진행하였습니다.\n\n\u003caside\u003e\n  24.9.10 v.3.19 업데이트 내용 추가하였습니다.\n\u003c/aside\u003e\n\n# 설치\n\n```bash\n// npm을 사용하는 경우\nnpm i next-intl\n\n// yarn을 사용하는 경우\nyarn add next-intl\n\n// pnpm을 사용하는 경우\npnpm i next-intl\n```\n\n다음과 같은 두 가지 경우에 해당하는 경우 i18n routing을 설정할 필요가 없습니다.\n\n1. 사용자 설정 등에 따라 언어 설정을 제공하는 경우\n2. 하나의 언어만 지원하는 경우\n\n저희 서비스는 사용자가 서비스 안에서 자유롭게 설정할 수 있도록 만들기 위해 [[next-intl]App Router: App Router setup with i18n routing](https://next-intl-docs.vercel.app/docs/getting-started/app-router/with-i18n-routing)  도움말에 따라 진행하겠습니다.\n\n# 폴더 구조 설정\n\n```\n├── messages\n│   ├── en.json (1)\n│   └── ...\n├── next.config.mjs (2)\n└── src\n    ├── i18n\n    │   ├── routing.ts (3)\n    │   └── request.ts (5)\n    ├── middleware.ts (4)\n    └── app\n        └── [locale]\n            ├── layout.tsx (6)\n            └── page.tsx (7)\n```\n\n## messages 폴더 생성\n\n`next.config.[mjs/js]`가 있는 디렉토리에 `messages` 폴더를 생성하여 `json` 파일을 생성합니다.\n\n```json\n// en.json\n{\n  \"SignUpPage\": {\n    \"title\": {...}\n  }\n}\n\n// ko.json\n{\n  \"SignUpPage\": {\n    \"title\": {\n      \"verify\": \"이메일 인증\",\n      \"register\": \"회원 정보 입력\"\n    }\n  }\n}\n```\n\n## next config 설정\n\n```jsx\nimport createNextIntlPlugin from 'next-intl/plugin';\n\nconst withNextIntl = createNextIntlPlugin();\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {};\n\nexport default withNextIntl(nextConfig);\n```\n\n## `routing.ts` 생성\n\n24년 9월 10일에 추가된 내용입니다.\n\n```jsx\n  import {defineRouting} from 'next-intl/routing';\n\n  export const routing = defineRouting({\n    locales: ['en', 'ko'],\n    defaultLocale: 'ko'\n  });\n```\n\n## `middleware.ts` 생성\n\n```tsx\nimport createMiddleware from 'next-intl/middleware';\nimport {routing} from \"@i18n/routing\";\n\n// export default createMiddleware({ =\u003e 업데이트: routing으로 변경\n// \t// A list of all locales that are supported\n// \tlocales: ['en', 'ko'],\n//\n// \t// Used when no locale matches\n// \tdefaultLocale: 'ko'\n// });\n\nexport default createMiddleware(routing);\n\nexport const config = {\n\t// Match only internationalized pathnames\n\tmatcher: ['/', '/(ko|en)/:path*']\n};\n```\n\n\n## `request.ts` 생성\n\n`i18n.ts` 에서 `i18n/request.ts`으로 변경되었습니다.\n\n```tsx\nimport {notFound} from 'next/navigation';\nimport {getRequestConfig} from 'next-intl/server';\nimport {routing} from \"@i18n/routing\";\n\n// Can be imported from a shared config\n// export const locales = ['en', 'ko'];  =\u003e 업데이트: routing으로 변경\n\nexport default getRequestConfig(async ({locale}) =\u003e {\n\t// Validate that the incoming `locale` parameter is valid\n\tif (!routing.locales.includes(locale as any)) notFound();\n\n\treturn {\n\t\tmessages: (await import(`../messages/${locale}.json`)).default\n\t};\n});\n```\n\n\n\n## `app/[locale]/layout.tsx` 설정\n\n```tsx\nimport {NextIntlClientProvider} from 'next-intl';\nimport {getMessages} from 'next-intl/server';\n\nexport default async function LocaleLayout({\n  children,\n  params: {locale}\n}: {\n  children: React.ReactNode;\n  params: {locale: string};\n}) {\n  // Providing all messages to the client\n  // side is the easiest way to get started\n  const messages = await getMessages();\n\n  return (\n    \u003chtml lang={locale}\u003e\n      \u003cbody\u003e\n        \u003cNextIntlClientProvider messages={messages}\u003e\n          {children}\n        \u003c/NextIntlClientProvider\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n# 사용하기\n\n```tsx\nexport default function RegisterPage() {\n\tconst t = useTranslations(\"SignUpPage\");\n\n\treturn (\n\t\t\u003c\u003e\n\t\t\t\u003ch1 className={\"title\"}\u003e{t(\"title.register\")}\u003c/h1\u003e\n\t\t\u003c/\u003e\n\t);\n}\n```\n\n# 추가 설정\n\n## Navigation APIs\n\n다음과 같이 설정해놓고 사용한다면 pathname에 locale을 입력하지 않고 사용 가능합니다.\n\n`routing.ts`\n\n```tsx\nimport {defineRouting} from 'next-intl/routing';\nimport {createSharedPathnamesNavigation} from 'next-intl/navigation';\n\n...\n\nexport const {Link, redirect, usePathname, useRouter} =\n\tcreateSharedPathnamesNavigation(routing);\n```\n\n만일 사용언어에 따라 다른 path를 쓴다면 `createLocalizedPathnamesNavigation` 사용하면 됩니다. 자세한 내용은 [공식 문서](https://next-intl-docs.vercel.app/docs/routing/navigation) 참고 바랍니다.\n\n# 참조\n\n- [[next-intl] App Router setup with i18n routing](https://next-intl-docs.vercel.app/docs/getting-started/app-router/with-i18n-routing)","fields":{"slug":"nextjs-intl"},"path":"nextjs-intl.mdx"},{"frontMatter":{"date":"2024-03-19T00:00:00","title":"NextJS 이미지 로딩 시에 Blur 처리하기","tags":["nextjs","plaiceholder"],"series":["blog"],"description":"plaiceholder 이용해서 nextjs 이미지 로딩 시에 이미지 Blur 처리하기","thumbnail":"https://github.com/coyo-hm/COYO-HM.github.io/assets/56423604/73748c95-2e16-4ff9-ae8d-a3bba5deb500","published":true,"path":"nextjs-image-blur.mdx","key":"nextjs-image-blur","blurThumbnail":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAFCAYAAAB8ZH1oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAApklEQVR4nC1OQQrCQAzcx/gkwRd48urZmz/w7hM8exN6ttD1IGypB0GsbSqF1nbVbEbSOjAJSWaGGGb+MnNQ9n0fvPcBQODPOxS3C2NEafTgnEOSJLDW4lGUeN6vWC1mmBgj281ahZVRNxEhyzJoV3bdC4f9Dsv5VM6n4ygUEY2XPM/FWitxHEsUReLSVIhI31DQkPgf0LYtmqZBXdfw3utKhiJS/QBvhbZ8aLo68wAAAABJRU5ErkJggg=="},"body":"블로그 화면 초기 진입 시 또는 새로고침 시에 이미지 로딩 시에 좀 더 매끄러운 사용자 경험을 위해 Nextjs 에서 제공하는 `\u003cImage/\u003e` 태그의 `placeholder`  `props`를 통해 `blur`를 적용해주기로 하였습니다.\n\n# blur 적용하기\n\n## 정적 이미지일 경우\n\n정적 이미지인 경우 굉장히 간단합니다. 그냥 `placeholder`의 옵션을 `blur`로 지정해 주기만 하면, `blurDataURL`를 설정해 주지 않아도 Nextjs가 자동으로 생성해 줍니다.\n\n```jsx\nimport Image from \"next/image\";\nimport ViewSource from \"../../components/view-source\";\nimport mountains from \"../../public/mountains.jpg\";\n\nconst PlaceholderBlur = () =\u003e (\n  \u003cdiv\u003e\n    \u003cViewSource pathname=\"app/placeholder/page.tsx\" /\u003e\n    \u003ch1\u003eImage Component With Placeholder Blur\u003c/h1\u003e\n    \u003cImage\n      alt=\"Mountains\"\n      src={mountains}\n      placeholder=\"blur\"\n      width={700}\n      height={475}\n      style={{\n        maxWidth: \"100%\",\n        height: \"auto\",\n      }}\n    /\u003e\n  \u003c/div\u003e\n);\n\nexport default PlaceholderBlur;\n```\n\n[[출처] nextjs examples](https://github.com/vercel/next.js/blob/canary/examples/image-component/app/placeholder/page.tsx)\n\n## 동적 이미지일 경우\n\n다만 저처럼 경우 블로그의 모든 이미지를 동적으로 가져오는 경우에는 `blurDataURL` 생성해서 입력해 주어야 합니다.\n\n직접 생성해도 되지만, 저의 경우 Nextjs 에서 권장하는 `plaiceholder` 라는 라이브러리를 사용해 주도록 하겠습니다.\n\n### 라이브러리 설치\n\n`plaiceholder` 을 사용하기 위해서는 `plaiceholder` 뿐만 아니라 이미지 최적화 라이브러리 `sharp` **를 함께 설치해 주어야 합니다.**\n\n  ```bash\n  # npm 사용 시\n  npm i sharp plaiceholder\n\n  # yarn 사용시\n  yarn add sharp plaiceholder\n  ```\n\n### 코드 작성\n\n다른 부분에도 쉽게 적용하기 위해 다음과 같이 함수를 작성해주었습니다.\n\n```tsx\n// getBlurImg.ts\nimport { getPlaiceholder } from \"plaiceholder\";\n\nconst getBlurImg = async (imgSrc: string) =\u003e {\n  try {\n    const buffer = await fetch(imgSrc).then(async (res) =\u003e\n      Buffer.from(await res.arrayBuffer())\n    );\n    const { base64 } = await getPlaiceholder(buffer, { size: 10 });\n    return base64;\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nexport default getBlurImg;\n\n```\n\n\u003caside\u003e\n  💡 `getPlaiceholder`\n\n  `[options](https://plaiceholder.co/docs/usage#parameters)`으로 `size`, `autoOrient`, `brightness`, `format,` `hue`,\n  `lightness`, `removeAlpha`, `saturation` 등을 지정하여 이미지에 다양한 설정을 할 수 있습니다.\n\n\u003c/aside\u003e\n\n작성한 함수를 컴포넌트에 적용해 봅시다.\n\n(참고, `index.tsx` ⇒ `Carousel.tsx` ⇒ `ActivePostCard.tsx` 으로 `post props` 전달)\n\n```tsx\n// index.tsx\n...\n\nexport const getStaticProps: GetStaticProps = async () =\u003e {\n  const recentPosts = await getPosts(0, 5);\n  const allTags = await getAllTags();\n  const allSeriesInfo = await getAllSeriesInfo();\n\n  const posts = await Promise.all(\n    recentPosts.map(async (post: PostType) =\u003e {\n      const blurThumbnail = await getBlurImg(post.frontMatter.thumbnail);\n      return { ...post, frontMatter: { ...post.frontMatter, blurThumbnail } };\n    })\n  );\n\n  return {\n    props: {\n      recentPosts: posts,\n      tags: allTags,\n      allSeriesInfo: allSeriesInfo,\n    },\n  };\n};\n```\n\n```tsx\n// ActivePostCard.tsx\n\n...\n\ninterface Props extends PostType {\n  currentIndex: number;\n  direction: DirectionType;\n  allSeriesInfo: SeriesAttributeTableType;\n}\n\nconst ActivePostCard = ({\n  currentIndex,\n  direction,\n  allSeriesInfo,\n  fields: { slug },\n  frontMatter: {\n    title,\n    tags,\n    date,\n    thumbnail,\n    description,\n    series,\n    blurThumbnail,\n  },\n}: Props) =\u003e {\n ...\n  return (\n    \u003cLink href={`/post/${slug}`} aria-label={`link-${slug}`}\u003e\n\t     ...\n         \u003cImage\n            src={thumbnail}\n            alt={title}\n            placeholder={\"blur\"}\n            blurDataURL={blurThumbnail}\n          /\u003e\n         ...\n    \u003c/Link\u003e\n  );\n};\n\nexport default ActivePostCard;\n\n```\n\n## 적용 결과\n\n### 적용 전\n\n\u003cimg alt=\"before-blur\"\n     src=\"https://github.com/coyo-hm/COYO-HM.github.io/assets/56423604/00f74eb3-373f-424a-970f-703835e3c224\" /\u003e\n\n### 적용 후\n\n\n\u003cimg alt=\"after-blur\"\n     src=\"https://github.com/coyo-hm/COYO-HM.github.io/assets/56423604/a62aea31-4d56-4d7f-a924-64fd0c599be9\" /\u003e\n\n이미지 로딩 시에 `blur` 효과가 적용된 것을 확인할 수 있습니다.\n\n# 참조\n\n- [[NextJS] image placeholder](https://nextjs.org/docs/pages/api-reference/components/image#placeholder)\n- [[plaiceholder] base64](https://plaiceholder.co/docs/usage#base64)","fields":{"slug":"nextjs-image-blur"},"path":"nextjs-image-blur.mdx"},{"frontMatter":{"date":"2024-03-14T00:00:00","title":"semantic-release: 커밋 메세지로 버전 및 변경 로그 관리까지","tags":["semamtic_release","github_actions"],"series":["commit-msg-management"],"description":"커밋 메세지로 Semantic Versioning 자동화부터 Change-log 자동 관리하기","thumbnail":"https://github.com/coyo-hm/coyo-ui/assets/56423604/ed4f42e7-931f-4ea8-9088-65ed1943f6f2","published":true,"path":"semantic-release.mdx","key":"semantic-release","blurThumbnail":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAFCAYAAAB8ZH1oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAnklEQVR4nGP4////7/////998eLF36fPXvwFsWH458+ff/5DwGsGkMCjR4//O9jb/bfwjv2/Yueh/////4PKQxg/f/58C1fo7OT4Pyu38H9Wce3//fv3/l8wf97/gwf2oyj88+jRo3/a+lb/xKTU/hkYWf9TVjf9x8kr8c/A1AHkBBB4AzYRxPr+49f/T5+/gunP377///vvH4gPNxEAcpun0RJzBMsAAAAASUVORK5CYII="},"body":"[이전 포스트](https://coyo-hm.github.io/post/husky-commlint)에서 commlint를 통해 commit message에 규칙을 강제해주었습니다. 이전 포스트의 연장선으로 commit message를 통해 프로젝트의 버전(Semantic Versioning)을 관리해주고 change log를 자동으로 작성해보도록 합시다.\n\n# Semantic Versioning(SemVer)\n\n우선 Semantic Versioning에 대해 알아봅시다.\n\nVersioning의 하나의 종류로 [Semantic Versioning(SemVer)](https://semver.org/lang/ko/) 버전 번호를 어떻게 정하고 올려야 하는지를 명시하는 규칙과 요구사항을 제안하는 명세입니다.\n\n\u003cimg width=\"705\" alt=\"semantic-versioning\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/51e04f2a-42d8-45d5-ae31-bf0b9c0299ab\"/\u003e\n\n- MAJOR : Breaking Change, 기존 버전과 호환되지 않게 API가 바뀌면 “주(主) 버전”\n- MINOR : Feature, 기존 버전과 호환되면서 새로운 기능을 추가할 때는 “부(部) 버전”\n- PATCH : Fix, 기존 버전과 호환되면서 버그를 수정한 것이라면 “수(修) 버전”\n\n\u003caside\u003e\n  ❓ 왜 Semantic Versioning을 관리해야 하나요?\n\n  - SemVer 을 통해 의존성 지옥에서 벗어날 수 있습니다.\n  명확한 기준을 토대로 작성 versioning 을 통해 우리는 3.1.x 버전이 3.2.x 버전과 호환되지만 4.x.x 버전과는 호환되지 않는다는 것을 알 수 있습니다. 우리는 이를 통해 필요에 따라 원하는 버전의 라이브러리는 versioning 만 보고 선택할 수 있습니다.\n  - SemVer 을 통해 대략적인 업데이트의 중요도를 확인할 수 있습니다.\n  보통의 프로젝트는 한 사람만이 담당하는 것이 아닌 여러 사람이 담당하게 됩니다. 명확한 기준을 정하여 versioning 을 관리하게 되면 다른 사람이 이 프로젝트의 history 를 쉽게 파악할 수 있게 됩니다.\n\u003c/aside\u003e\n\n# semantic-release\n\nsemantic-release 는 node.js 환경에서 사용자가 설정한 메인 브랜치를 기준으로 커밋 메세지 규칙을 통해 github와 npm에서 코드 변경 사항 문서화 및 자동 릴리스 및 버전업 등 다양한 기능을 제공하는 package 입니다.\n\n유사한 릴리즈 패키지 중에 가장 다운로드 수도 많고 업데이트도 꾸준히 이루어지는 이유로 semantic-release를 선택하였습니다.\n\n\n\u003cimg alt=\"npm-trends\" src=\"https://github.com/coyo-hm/COYO-HM.github.io/assets/56423604/774f71c9-aad8-463f-b284-2ff52f978e12\" /\u003e\n[npm trends](https://npmtrends.com/)\n\n\n\n## 적용하기\n\n### 설치\n\n다음 명령어를 입력하여 `semantic-release`를 설치해주도록 합시다.\n\n```bash\nnpm install --save-dev semantic-release\n```\n\n### package.json 수정\n\n`package.json` 에 다음과 같이 `private` 정보를 설정해줍니다.\n\n`private`은 npm package로 배포할 건지의 여부에 따라 설정해 줍니다. 배포를 원하는 경우 `false`, 아닐 경우에는 `true`로 설정해 줍니다.\n\n```json\n{\n\t...,\n\t\"private\": false,\n\t...\n}\n```\n\n### 플러그인 설치\n\n`@semantic-release/commit-analyzer`, `@semantic-release/release-notes-generator`, `@semantic-release/npm`, `@semantic-release/github` 이 4개는 semantic-release의 필수 플러그인으로 사용여부와 상관없이 설치해주셔야 됩니다.\n\n```bash\nnpm i -D @semantic-release/commit-analyzer @semantic-release/release-notes-generator @semantic-release/npm @semantic-release/github\n```\n\n간단하게 각각 플러그인의 역할을 설명하자면,\n\n- `@semantic-release/commit-analyzer` : commit message를 분석하는 플러그인입니다.\n- `@semantic-release/release-notes-generator` : 분석된 commit message를 가지고 지정한 규칙에 따라 릴리즈 노트를 생성하는 플러그인입니다.\n- `@semantic-release/npm` : `package.json`에 version을 수정하고 npm 에 배포를 담당하는 플러그인입니다.\n- `@semantic-release/github` : github release를 생성하고 해당 release를 `pull request`하는 플러그인입니다.\n\n위의 필수 플러그인 외에도 `semantic-release` 에는 정말 많은 플러그인들이 존재합니다. 그리고 다양한 플러그인에 대한 설명이 [공식 플러그인 문서](https://semantic-release.gitbook.io/semantic-release/extending/plugins-list)에 상당히 잘 정리되어있으니 해당 문서를 반드시 참조해주시길 바랍니다.\n\n저는 changelog를 생성해주고 싶고 release commit을 자동으로 push 해주고 tag 를 생성해주기 위해 추가적으로 플러그인을 설치해주었습니다.\n\n```bash\nnpm install @semantic-release/git @semantic-release/changelog -D\n```\n\n### Configuration 설정하기\n\n플러그인을 다 설치해주었으면 root directory에 Configuration 파일을 생성해줍니다. 파일명을 `.releaserc` 로, `yaml` 또는 `json` 파일로 생성해주면 됩니다.\n\n저는 `json` 파일로 생성해주었습니다.\n\n생성한 `.releaserc.json` 파일에 다음과 같이 branch 정보를 추가해 줍니다.\n\n```json\n{\n\t\"branches\": [\"main\", \"next\"]\n}\n```\n\n이어서 설치한 플러그인 정보를 입력해 줍니다. 각각의 플러그인에는 순서와 필수 추가 플러그인이 존재하지 반드시 해당 내용을 [공식문서](https://semantic-release.gitbook.io/semantic-release/extending/plugins-list)와 플러그인 `readme`를 참조해주시기를 바랍니다.\n\n```json\n{\n\t\"branches\": [\"main\", \"next\"],\n\t\"plugins\": [\n\t\t\"@semantic-release/commit-analyzer\",\n\t\t\"@semantic-release/release-notes-generator\",\n\t\t\"@semantic-release/changelog\",\n\t\t\"@semantic-release/npm\",\n\t\t\"@semantic-release/github\",\n\t\t\"@semantic-release/git\"\n\t]\n}\n```\n\n기본적으로 `conventionalcommits`을 따르고 있기에 다음과 같은 패키지를 설치해서 preset으로 지정합니다.\n\n`conventionalcommits` 이외에도 다양한 preset이 존재하니 [`@semantic-release/commit-analyzer` 의 readme](https://github.com/semantic-release/commit-analyzer?tab=readme-ov-file#options)를 참고해주세요.\n\n❕`preset` 없이도 진행할 수 있습니다!\n\n```bash\n  # yarn\n  yarn add -D conventional-changelog-conventionalcommits\n  # pnpm\n  pnpm add -D conventional-changelog-conventionalcommits\n  # npm\n  npm i -D conventional-changelog-conventionalcommits\n```\n\n각각의 플러그인 또한 설정을 해줍시다.\n\n`.releaserc.json` 파일의 전체 코드를 보면 다음과 같습니다.\n\n```json\n{\n  \"branches\": [\n    \"main\", \"next\"\n  ],\n  \"plugins\": [\n    [\n      \"@semantic-release/commit-analyzer\",\n      {\n        \"preset\": \"conventionalcommits\",\n        \"releaseRules\": [\n          { \"scope\": \"breaking\", \"release\": \"major\" },\n          { \"scope\": \"no-release\", \"release\": false },\n          { \"type\": \"build\", \"release\": false },\n          { \"type\": \"chore\", \"release\": false },\n          { \"type\": \"ci\", \"release\": false },\n          { \"type\": \"docs\", \"release\": \"patch\" },\n          { \"type\": \"feat\", \"release\": \"minor\" },\n          { \"type\": \"fix\", \"release\": \"patch\" },\n          { \"type\": \"perf\", \"release\": \"patch\" },\n          { \"type\": \"refactor\", \"release\": \"patch\" },\n          { \"type\": \"revert\", \"release\": \"patch\" },\n          { \"type\": \"style\", \"release\": \"patch\" },\n          { \"type\": \"test\", \"release\": false }\n        ],\n        \"parserOpts\": {\n          \"noteKeywords\": [\n            \"BREAKING CHANGE\",\n            \"BREAKING CHANGES\"\n          ]\n        }\n      }\n    ],\n    [\"@semantic-release/release-notes-generator\",\n      {\n        \"preset\": \"conventionalcommits\",\n        \"presetConfig\": {\n          \"types\": [\n            { \"type\": \"build\", \"section\": \"⚙️ SYSTEM BUILD \u0026 EXTERNAL PACKAGES\", \"hidden\": true },\n            { \"type\": \"chore\", \"section\": \"\\uD83D\\uDCE6 CHORES\", \"hidden\": true },\n            { \"type\": \"ci\", \"section\": \"\\uD83E\\uDE9C CI/CD\", \"hidden\": true },\n            { \"type\": \"docs\", \"section\": \"\\uD83D\\uDCDD DOCS\", \"hidden\": false },\n            { \"type\": \"feat\", \"section\": \"\\uD83D\\uDE80 FEATURES\", \"hidden\": false },\n            { \"type\": \"fix\", \"section\": \"\\uD83D\\uDC1B BUG FIXES\", \"hidden\": false },\n            { \"type\": \"perf\", \"section\": \"♻\\uFE0F PERFORMANCE\", \"hidden\": false },\n            { \"type\": \"refactor\", \"section\": \"♻\\uFE0F REFACTOR\", \"hidden\": false },\n            { \"type\": \"revert\", \"section\": \"↩\\uFE0F REVERTS\", \"hidden\": false },\n            { \"type\": \"style\", \"section\": \"\\uD83D\\uDC69\\u200D\\uD83C\\uDFA4 STYLES\", \"hidden\": false },\n            { \"type\": \"test\", \"section\": \"✅ TESTS\", \"hidden\": true }\n          ]\n        },\n        \"parserOpts\": {\n          \"noteKeywords\": [\n            \"BREAKING CHANGE\",\n            \"BREAKING CHANGES\"\n          ]\n        },\n        \"writerOpts\": {\n          \"commitsSort\": [\"subject\", \"scope\"]\n        }\n      }\n    ],\n    [\n      \"@semantic-release/changelog\",\n      {\n        \"changelogFile\": \"CHANGELOG.md\",\n        \"changelogTitle\": \"# CHANGELOG\"\n      }\n    ],\n    [\"@semantic-release/npm\",\n      {\n        \"pkgRoot\": \".\",\n        \"tarball\": \"dist\"\n      }\n    ],\n    \"@semantic-release/github\",\n    [\n      \"@semantic-release/git\",\n      {\n        \"assets\": [\n          \"package.json\",\n          \"package-lock.json\",\n          \"CHANGELOG.md\"\n        ],\n        \"message\": \"chore(release): ${nextRelease.version} [skip ci]\\n\\n${nextRelease.notes}\"\n      }\n    ]\n  ]\n}\n```\n\n### Token 발급받기\n\n#### Github Token\n\n[github token 발급 링크](https://github.com/settings/tokens) 를 클릭해서 repo, workflow, write:packages 의 권한을 가진 github token을 발급받아 줍니다.\n\n발급 받은 토큰을 복사해 semantic-release를 적용해줄 repository의 Settings \u003e Secrets and variables \u003e Actions 메뉴에 들어가줍니다.\n\n\u003cimg alt=\"\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/91f8a4b4-3277-454e-b9af-39542ce564d8\" /\u003e\n\n\n\u003cimg alt=\"settings\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/9000a3c0-cc5e-4861-b38b-ca8ebd43c3fa\" /\u003e\n\n\u003cimg alt=\"repo-secrets\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/e4a00eaa-560c-4018-9ae1-6149fbfdc65a\" /\u003e\n\n\u003cimg alt=\"new-secrets\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/27419bcc-f364-4229-9317-e36da94c83bb\" /\u003e\n\n새로운 repository secret을 생성해주는데 이때 반드시 Name을 `GH_TOKEN`이라고 작성해야합니다.\n\nSecret에는 복사해준 토큰을 붙여넣어 줍니다.\n\n#### NPM Token\n\n`semantic-release` 를 통해 npm package 배포 및 관리를 하고 싶다면 NPM Token도 필요합니다.\n\n다음과 같은 명령어를 통해 npm 관련 설정을 진행합니다.\n\n```bash\nnpx semantic-release-cli setup\n```\n\n\n\u003cimg alt=\"config-semantic\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/4fd314c9-9df9-4cf5-812b-baed33112b7e\" /\u003e\n\n차례로 질문이 나오는 데 이에 맞게 응답해 주시면 됩니다. 해당 과정을 완료하면 npm_token이 생성된 것을 확인할 수 있습니다.\n\n\n\u003cimg alt=\"repo-secrets\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/ace73a32-67e5-4237-8338-688b82fe5988\" /\u003e\n\n### Github Action 작성하기\n\n이제 여기까지 진행하면 거의 다 되었습니다. 이제 실행할 action을 생성합니다.\n\n\n\u003cimg alt=\"github-action1\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/f916e4ac-7522-4fd3-b5d2-08acaa960d97\" /\u003e\n\n\n\u003cimg alt=\"github-action2\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/ba5a922f-bb76-43a8-bcd0-7755fb1a729f\" /\u003e\n\n\n\u003cimg alt=\"github-action3\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/86b1e3c9-a5b7-4a25-ab4f-d78e89435474\" /\u003e\n\n파일명은 본인이 원하시는 대로 작성하시면 됩니다. 저는 다음과 같이 workflow를 지정해주었습니다.\n\n```yaml\nname: Semantic-release\n\non:\n  push: # main에 push할때 해당 workflow 실행\n    branches: [\"main\", \"next\"]\n\npermissions:\n  contents: read # for checkout\n\njobs:\n  release:\n    name: release\n    runs-on: ubuntu-latest\n    permissions:\n     contents: write # to be able to publish a GitHub release\n      issues: write # to be able to comment on released issues\n      pull-requests: write # to be able to comment on released pull requests\n      id-token: write # to enable use of OIDC for npm provenance\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          cache: npm\n          node-version: \"lts/*\"\n          registry-url: \"https://npm.pkg.github.com/\"\n          scope: '@github-id'\n      - run: npm ci\n      - run: npm run build\n      - run: npx semantic-release\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }} # npm에 업로드 하시지 않으실 경우 작성하지 않아도 됩니다.\n\n```\n\n이런식으로 github에서 추가해주셔도 되지만 directory에서 직접 추가해주셔도 됩니다.\n\n## 결과보기\n\n이제 main 브랜치에 push를 하게되면, 다음과 같이 action이 진행됩니다.\n\n\n\u003cimg alt=\"github-action\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/0a5d8ea2-9d0f-47aa-b5ba-593c21cfc0fd\" /\u003e\n\naction이 완료되면 commit message에 따라\n\n- package.json에 semantic versioning이 바뀝니다.\n- changelog가 작성됩니다.\n\n\n\u003cimg alt=\"github-changelog\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/0e8b1372-811b-4dc9-acf1-529868389225\" /\u003e\n\n- git tag와 release가 생성됩니다.\n\n\n\u003cimg alt=\"github-tag\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/00dc769e-d9ef-467e-b0e4-579c7ec1f82b\" /\u003e\n\n\n\u003cimg alt=\"github-release\" src=\"https://github.com/coyo-hm/coyo-ui/assets/56423604/065bddc0-f1bc-4c92-8f2b-61f0b0151144\" /\u003e\n\n- npm에 package가 publish 됩니다.\n\n# 마치며\n\n저는 여기까지 진행했습니다만 github issue관리와 jira issue 또한 연동해서 함께 관리할 수 있습니다.\n\n설정하기까지는 조금 과정이 많지만 한번 설정하고 나면 여러모로 편해서 아예 이런 저런 방식으로 template을 만들어서 사용하는 것도 좋아보입니다.\n\n혹시 틀린 내용이나 더 좋은 내용이 있다면 댓글로 알려주세요:)\n\n# 참조\n\n- [semantic-release](https://semantic-release.gitbook.io/semantic-release/)\n- https://github.com/semantic-release/semantic-release.git\n- [CRA Custom Template 생성, NPM 에 게시 및 CI/CD 구성하기 (2)](https://leesuhyung.medium.com/cra-custom-template-%EC%83%9D%EC%84%B1-npm-%EC%97%90-%EA%B2%8C%EC%8B%9C-%EB%B0%8F-ci-cd-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0-2-f937ffc12764)","fields":{"slug":"semantic-release"},"path":"semantic-release.mdx"},{"frontMatter":{"date":"2024-02-20T00:00:00","title":"Application Layer: 2. DNS","tags":["network","computer_science"],"series":["network_note"],"description":"DNS","thumbnail":"https://github.com/coyo-hm/COYO-HM.github.io/assets/56423604/156d2cd6-ac5f-496b-8a89-2dde74058d58","published":true,"path":"network-application-02.mdx","key":"network-application-02","blurThumbnail":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAFCAYAAAB8ZH1oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAlUlEQVR4nG1OOwoCMRTMCSw9SU6xYpMyreANPIGVt/AGNlsYLETQQrCwSZsmhYJuETBRnps3EpWtdmCYZn4CwBtA7iMRtfjhJlJK+bBbYVmvsT2d8UwRjxgRQijk4iKiRpTkZFpBDAeYzRcYjypIKaG1hlKKjTGdsfXXC2+Oe6YXsXOOrbXsvS+aSzOA+7fx/6MP3fQHq7WxBLJ4NPMAAAAASUVORK5CYII="},"body":"  \u003caside\u003e\n    💡 본 포스트는 [링크된 강의](http://www.kocw.net/home/cview.do?lid=74b934572332b6ba)를 듣고 정리한 내용입니다.\n\n  \u003c/aside\u003e\n\n# DNS: Domain Name System\n\n호스트 이름으로 매핑된 ip를 가지고 이를 매핑 시켜준다.\n\n\u003caside\u003e\n  💡 DNS는 Application 계층에서 제공하는 서비스로 정보값이 작기에 유실되어도 피해가 적고 준비동작이기에 자원 낭비를 최소화하고자 UDP를 이용한다.\n\u003c/aside\u003e\n\n\u003caside\u003e\n  🔥 하나의 서버에서 이를 매핑하기엔 전세계의 모든 접속을 감당해야 하며 무한의 DB(: Domain과 IP 정보를 저장해야 하는 DB)가 필요하기에 현실적으로 불가능하다.\n\n  따라서 DNS는 계층적이고 분산적이다.\n\n  (규모가 커지면 감당되지 않기 때문에 잘라서(분산해서) 계층화시킨다.)\n\u003c/aside\u003e\n\nA Distributed, hierarchical Database(계층적이고 분산적인 DB)\n\n- Distributed: 하나의 장애가 전체에 영향이 가지 않도록 분산되어 있다.\n- Hierarchical: 관리에 용이하고 계산속도를 더욱 빠르게 하기 위해 계층화되어 있다.\n\n\u003cimg width=\"1719\" alt=\"image\" src=\"https://github.com/coyo-hm/COYO-HM.github.io/assets/56423604/ee1af8f3-eca3-4957-9f12-c7e5d901f058\"/\u003e\n\n## Root DNS Servers\n\n- 가장 상위에 존재하는 서버로 전세계에 분산적으로 같은 데이터를 가지고 있는 13 곳이 존재한다.\n- 매핑할 수 없는 이름을 받은 경우 authoritative server에 문의하여 local name server로 매핑시켜준다.\n\n## TLD, authoritative Servers\n\n### TLD(top-level-domain) Servers\n\n- com, org, net, edu, aero, jobs, museums 등과 uk, fr, ca, jp 등과 같은 모든 top-level 국가 도메인 등에 대한 책임을 가지고 있다.\n\n### authoritative DNS Servers\n\n- 네트워크를 운영하는 기관은 각자의 authoritative DNS 서버를 운영해야 한다.\n- 각 기관이 보유하고 있는 도메인에 속하는 호스트네임을 ip 매핑에 대한 책임을 가진 서버이다.\n\n## Local DNS name server\n\n- 가져온 domain과 ip 주소에 대해 캐싱하는 서버로 계층에는 포함되지 않는다.\n- 각각의 ISP(residential ISP, company, university) 는 default name server로 하나를 가지고 있다.\n- local 사용자들이 DNS query를 보내면 우선 local DNS Server에 문의하고 캐시가 없거나 기한이 지났다면 외부로 Query를 보낸다.\n\n# DNS name resolution Example\n\n: 호스트 네임을 가지고 ip 주소 가져오기\n\n\u003cimg width=\"1752\" alt=\"image\" src=\"https://github.com/coyo-hm/COYO-HM.github.io/assets/56423604/a308070a-e50c-4d47-9ebc-b33d1f929eed\"/\u003e\n\n# DNS records\n\n: DNS DB 저장 정보로 각 record는 4개의 field로 구성되어 있습니다.\n\n\n\u003cimg width=\"759\" alt=\"image\" src=\"https://github.com/coyo-hm/COYO-HM.github.io/assets/56423604/5870e9b8-2ba8-416b-9552-35e34d4cf92e\"/\u003e\n\n`type`에는 `A`, `NS`, `CNAME`, `MX` 총 4개의 값이 들어간다.\n\n- `type = A` 인 경우, `name`은 hostname, `value`는 IP 주소를 의미한다.\n- `type = NS` 인 경우, `name`은 domain, `value`는 해당 domain의 authoritative name의 hostname을 의미한다.\n- `type = CNAME` 인 경우, `name`은 하위 name, `value` 는 해당 소속된 상위의 name\n- `type = MX` 인 경우, 메일 서버의 정보\n\n\u003caside\u003e\n  🔥 local DNS Server에서 cache를 사용하기에 일관성 문제가 발생한다.\n\n  ⇒ 이를 해결하기 위해 TTL(Time To Live)이란 Field를 사용한다.\n\n  TTL은 해당 캐시가 유효한 기간을 의미하는 Field로 지정된 시간이 지나면 해당 record는 파기된다.\n\n\u003c/aside\u003e","fields":{"slug":"network-application-02"},"path":"network-application-02.mdx"}],"allTags":[{"tag":"all","count":42},{"tag":"typescript","count":12},{"tag":"react","count":12},{"tag":"javascript","count":11},{"tag":"nextjs","count":7},{"tag":"network","count":7},{"tag":"git","count":5},{"tag":"computer_science","count":4},{"tag":"npm","count":3},{"tag":"vite","count":3},{"tag":"husky","count":3},{"tag":"yarn","count":2},{"tag":"emotion","count":2},{"tag":"styled_components","count":2},{"tag":"css","count":2},{"tag":"redux","count":2},{"tag":"axios","count":2},{"tag":"yarn_berry","count":1},{"tag":"giscus","count":1},{"tag":"utterances","count":1},{"tag":"semamtic_release","count":1},{"tag":"github_actions","count":1},{"tag":"reg_exp","count":1},{"tag":"redux_persist","count":1},{"tag":"python3","count":1},{"tag":"react_beautiful_dnd","count":1},{"tag":"react_hook_form","count":1},{"tag":"recoil","count":1},{"tag":"next_intl","count":1},{"tag":"plaiceholder","count":1},{"tag":"gtag","count":1},{"tag":"google_analytics","count":1},{"tag":"lodash","count":1},{"tag":"commitlint","count":1},{"tag":"githubpage","count":1},{"tag":"intellij","count":1},{"tag":"gatsby","count":1},{"tag":"framer_motion","count":1},{"tag":"tailwind","count":1},{"tag":"vanilla_extract","count":1}],"selectedTag":"all","page":0},"__N_SSG":true},"page":"/post/page/[page]/[tag]","query":{"page":"0","tag":"all"},"buildId":"d4lrTSL5DgHi3vKwnjH5I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>